# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/urllib/parse.py
from __future__ import absolute_import, division, unicode_literals
from future.builtins import bytes, chr, dict, int, range, str
from future.utils import raise_with_traceback
import re
import sys
import collections
__all__ = [u'urlparse',
 u'urlunparse',
 u'urljoin',
 u'urldefrag',
 u'urlsplit',
 u'urlunsplit',
 u'urlencode',
 u'parse_qs',
 u'parse_qsl',
 u'quote',
 u'quote_plus',
 u'quote_from_bytes',
 u'unquote',
 u'unquote_plus',
 u'unquote_to_bytes']
uses_relative = [u'ftp',
 u'http',
 u'gopher',
 u'nntp',
 u'imap',
 u'wais',
 u'file',
 u'https',
 u'shttp',
 u'mms',
 u'prospero',
 u'rtsp',
 u'rtspu',
 u'',
 u'sftp',
 u'svn',
 u'svn+ssh']
uses_netloc = [u'ftp',
 u'http',
 u'gopher',
 u'nntp',
 u'telnet',
 u'imap',
 u'wais',
 u'file',
 u'mms',
 u'https',
 u'shttp',
 u'snews',
 u'prospero',
 u'rtsp',
 u'rtspu',
 u'rsync',
 u'',
 u'svn',
 u'svn+ssh',
 u'sftp',
 u'nfs',
 u'git',
 u'git+ssh']
uses_params = [u'ftp',
 u'hdl',
 u'prospero',
 u'http',
 u'imap',
 u'https',
 u'shttp',
 u'rtsp',
 u'rtspu',
 u'sip',
 u'sips',
 u'mms',
 u'',
 u'sftp',
 u'tel']
non_hierarchical = [u'gopher',
 u'hdl',
 u'mailto',
 u'news',
 u'telnet',
 u'wais',
 u'imap',
 u'snews',
 u'sip',
 u'sips']
uses_query = [u'http',
 u'wais',
 u'imap',
 u'https',
 u'shttp',
 u'mms',
 u'gopher',
 u'rtsp',
 u'rtspu',
 u'sip',
 u'sips',
 u'']
uses_fragment = [u'ftp',
 u'hdl',
 u'http',
 u'gopher',
 u'news',
 u'nntp',
 u'wais',
 u'https',
 u'shttp',
 u'snews',
 u'file',
 u'prospero',
 u'']
scheme_chars = u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.'
MAX_CACHE_SIZE = 20
_parse_cache = {}

def clear_cache():
    _parse_cache.clear()
    _safe_quoters.clear()


_implicit_encoding = u'ascii'
_implicit_errors = u'strict'

def _noop(obj):
    return obj


def _encode_result(obj, encoding=_implicit_encoding, errors=_implicit_errors):
    return obj.encode(encoding, errors)


def _decode_args(args, encoding=_implicit_encoding, errors=_implicit_errors):
    return tuple(((x.decode(encoding, errors) if x else u'') for x in args))


def _coerce_args(*args):
    str_input = isinstance(args[0], str)
    for arg in args[1:]:
        if arg and isinstance(arg, str) != str_input:
            raise TypeError(u'Cannot mix str and non-str arguments')

    return args + (_noop,) if str_input else _decode_args(args) + (_encode_result,)


class _ResultMixinStr(object):
    __slots__ = ()

    def encode(self, encoding=u'ascii', errors=u'strict'):
        return self._encoded_counterpart(*(x.encode(encoding, errors) for x in self))


class _ResultMixinBytes(object):
    __slots__ = ()

    def decode(self, encoding=u'ascii', errors=u'strict'):
        return self._decoded_counterpart(*(x.decode(encoding, errors) for x in self))


class _NetlocResultMixinBase(object):
    __slots__ = ()

    @property
    def username(self):
        return self._userinfo[0]

    @property
    def password(self):
        return self._userinfo[1]

    @property
    def hostname(self):
        hostname = self._hostinfo[0]
        if not hostname:
            hostname = None
        elif hostname is not None:
            hostname = hostname.lower()
        return hostname

    @property
    def port(self):
        port = self._hostinfo[1]
        if port is not None:
            port = int(port, 10)
            if not 0 <= port <= 65535:
                return
        return port


class _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition(u'@')
        if have_info:
            username, have_password, password = userinfo.partition(u':')
            if not have_password:
                password = None
        else:
            username = password = None
        return (username, password)

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition(u'@')
        _, have_open_br, bracketed = hostinfo.partition(u'[')
        if have_open_br:
            hostname, _, port = bracketed.partition(u']')
            _, have_port, port = port.partition(u':')
        else:
            hostname, have_port, port = hostinfo.partition(u':')
        if not have_port:
            port = None
        return (hostname, port)


class _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition('@')
        if have_info:
            username, have_password, password = userinfo.partition(':')
            if not have_password:
                password = None
        else:
            username = password = None
        return (username, password)

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition('@')
        _, have_open_br, bracketed = hostinfo.partition('[')
        if have_open_br:
            hostname, _, port = bracketed.partition(']')
            _, have_port, port = port.partition(':')
        else:
            hostname, have_port, port = hostinfo.partition(':')
        if not have_port:
            port = None
        return (hostname, port)


from collections import namedtuple
_DefragResultBase = namedtuple(u'DefragResult', u'url fragment')
_SplitResultBase = namedtuple(u'SplitResult', u'scheme netloc path query fragment')
_ParseResultBase = namedtuple(u'ParseResult', u'scheme netloc path params query fragment')
ResultBase = _NetlocResultMixinStr

class DefragResult(_DefragResultBase, _ResultMixinStr):
    __slots__ = ()

    def geturl(self):
        if self.fragment:
            return self.url + u'#' + self.fragment
        else:
            return self.url


class SplitResult(_SplitResultBase, _NetlocResultMixinStr):
    __slots__ = ()

    def geturl(self):
        return urlunsplit(self)


class ParseResult(_ParseResultBase, _NetlocResultMixinStr):
    __slots__ = ()

    def geturl(self):
        return urlunparse(self)


class DefragResultBytes(_DefragResultBase, _ResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        if self.fragment:
            return self.url + '#' + self.fragment
        else:
            return self.url


class SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        return urlunsplit(self)


class ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):
    __slots__ = ()

    def geturl(self):
        return urlunparse(self)


def _fix_result_transcoding():
    _result_pairs = ((DefragResult, DefragResultBytes), (SplitResult, SplitResultBytes), (ParseResult, ParseResultBytes))
    for _decoded, _encoded in _result_pairs:
        _decoded._encoded_counterpart = _encoded
        _encoded._decoded_counterpart = _decoded


_fix_result_transcoding()
del _fix_result_transcoding

def urlparse(url, scheme=u'', allow_fragments=True):
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    splitresult = urlsplit(url, scheme, allow_fragments)
    scheme, netloc, url, query, fragment = splitresult
    if scheme in uses_params and u';' in url:
        url, params = _splitparams(url)
    else:
        params = u''
    result = ParseResult(scheme, netloc, url, params, query, fragment)
    return _coerce_result(result)


def _splitparams(url):
    if u'/' in url:
        i = url.find(u';', url.rfind(u'/'))
        if i < 0:
            return (url, u'')
    else:
        i = url.find(u';')
    return (url[:i], url[i + 1:])


def _splitnetloc(url, start=0):
    delim = len(url)
    for c in u'/?#':
        wdelim = url.find(c, start)
        if wdelim >= 0:
            delim = min(delim, wdelim)

    return (url[start:delim], url[delim:])


def urlsplit(url, scheme=u'', allow_fragments=True):
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    allow_fragments = bool(allow_fragments)
    key = (url,
     scheme,
     allow_fragments,
     type(url),
     type(scheme))
    cached = _parse_cache.get(key, None)
    if cached:
        return _coerce_result(cached)
    else:
        if len(_parse_cache) >= MAX_CACHE_SIZE:
            clear_cache()
        netloc = query = fragment = u''
        i = url.find(u':')
        if i > 0:
            if url[:i] == u'http':
                scheme = url[:i].lower()
                url = url[i + 1:]
                if url[:2] == u'//':
                    netloc, url = _splitnetloc(url, 2)
                    if u'[' in netloc and u']' not in netloc or u']' in netloc and u'[' not in netloc:
                        raise ValueError(u'Invalid IPv6 URL')
                if allow_fragments and u'#' in url:
                    url, fragment = url.split(u'#', 1)
                if u'?' in url:
                    url, query = url.split(u'?', 1)
                v = SplitResult(scheme, netloc, url, query, fragment)
                _parse_cache[key] = v
                return _coerce_result(v)
            for c in url[:i]:
                if c not in scheme_chars:
                    break
            else:
                rest = url[i + 1:]
                if not rest or any((c not in u'0123456789' for c in rest)):
                    scheme, url = url[:i].lower(), rest
        if url[:2] == u'//':
            netloc, url = _splitnetloc(url, 2)
            if u'[' in netloc and u']' not in netloc or u']' in netloc and u'[' not in netloc:
                raise ValueError(u'Invalid IPv6 URL')
        if allow_fragments and u'#' in url:
            url, fragment = url.split(u'#', 1)
        if u'?' in url:
            url, query = url.split(u'?', 1)
        v = SplitResult(scheme, netloc, url, query, fragment)
        _parse_cache[key] = v
        return _coerce_result(v)


def urlunparse(components):
    scheme, netloc, url, params, query, fragment, _coerce_result = _coerce_args(*components)
    if params:
        url = u'%s;%s' % (url, params)
    return _coerce_result(urlunsplit((scheme,
     netloc,
     url,
     query,
     fragment)))


def urlunsplit(components):
    scheme, netloc, url, query, fragment, _coerce_result = _coerce_args(*components)
    if netloc or scheme and scheme in uses_netloc and url[:2] != u'//':
        if url and url[:1] != u'/':
            url = u'/' + url
        url = u'//' + (netloc or u'') + url
    if scheme:
        url = scheme + u':' + url
    if query:
        url = url + u'?' + query
    if fragment:
        url = url + u'#' + fragment
    return _coerce_result(url)


def urljoin(base, url, allow_fragments=True):
    if not base:
        return url
    if not url:
        return base
    base, url, _coerce_result = _coerce_args(base, url)
    bscheme, bnetloc, bpath, bparams, bquery, bfragment = urlparse(base, u'', allow_fragments)
    scheme, netloc, path, params, query, fragment = urlparse(url, bscheme, allow_fragments)
    if scheme != bscheme or scheme not in uses_relative:
        return _coerce_result(url)
    if scheme in uses_netloc:
        if netloc:
            return _coerce_result(urlunparse((scheme,
             netloc,
             path,
             params,
             query,
             fragment)))
        netloc = bnetloc
    if path[:1] == u'/':
        return _coerce_result(urlunparse((scheme,
         netloc,
         path,
         params,
         query,
         fragment)))
    if not path and not params:
        path = bpath
        params = bparams
        if not query:
            query = bquery
        return _coerce_result(urlunparse((scheme,
         netloc,
         path,
         params,
         query,
         fragment)))
    segments = bpath.split(u'/')[:-1] + path.split(u'/')
    if segments[-1] == u'.':
        segments[-1] = u''
    while u'.' in segments:
        segments.remove(u'.')

    while 1:
        i = 1
        n = len(segments) - 1
        while i < n:
            if segments[i] == u'..' and segments[i - 1] not in (u'', u'..'):
                del segments[i - 1:i + 1]
                break
            i = i + 1
        else:
            break

    if segments == [u'', u'..']:
        segments[-1] = u''
    elif len(segments) >= 2 and segments[-1] == u'..':
        segments[-2:] = [u'']
    return _coerce_result(urlunparse((scheme,
     netloc,
     u'/'.join(segments),
     params,
     query,
     fragment)))


def urldefrag(url):
    url, _coerce_result = _coerce_args(url)
    if u'#' in url:
        s, n, p, a, q, frag = urlparse(url)
        defrag = urlunparse((s,
         n,
         p,
         a,
         q,
         u''))
    else:
        frag = u''
        defrag = url
    return _coerce_result(DefragResult(defrag, frag))


_hexdig = u'0123456789ABCDEFabcdef'
_hextobyte = dict((((a + b).encode(), bytes([int(a + b, 16)])) for a in _hexdig for b in _hexdig))

def unquote_to_bytes(string):
    if not string:
        string.split
        return bytes('')
    if isinstance(string, str):
        string = string.encode(u'utf-8')
    string = bytes(string)
    bits = string.split('%')
    if len(bits) == 1:
        return string
    res = [bits[0]]
    append = res.append
    for item in bits[1:]:
        try:
            append(_hextobyte[item[:2]])
            append(item[2:])
        except KeyError:
            append('%')
            append(item)

    return bytes('').join(res)


_asciire = re.compile(u'([\x00-\x7f]+)')

def unquote(string, encoding=u'utf-8', errors=u'replace'):
    if u'%' not in string:
        string.split
        return string
    else:
        if encoding is None:
            encoding = u'utf-8'
        if errors is None:
            errors = u'replace'
        bits = _asciire.split(string)
        res = [bits[0]]
        append = res.append
        for i in range(1, len(bits), 2):
            append(unquote_to_bytes(bits[i]).decode(encoding, errors))
            append(bits[i + 1])

        return u''.join(res)


def parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding=u'utf-8', errors=u'replace'):
    parsed_result = {}
    pairs = parse_qsl(qs, keep_blank_values, strict_parsing, encoding=encoding, errors=errors)
    for name, value in pairs:
        if name in parsed_result:
            parsed_result[name].append(value)
        parsed_result[name] = [value]

    return parsed_result


def parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding=u'utf-8', errors=u'replace'):
    qs, _coerce_result = _coerce_args(qs)
    pairs = [ s2 for s1 in qs.split(u'&') for s2 in s1.split(u';') ]
    r = []
    for name_value in pairs:
        if not name_value and not strict_parsing:
            continue
        nv = name_value.split(u'=', 1)
        if len(nv) != 2:
            if strict_parsing:
                raise ValueError(u'bad query field: %r' % (name_value,))
            if keep_blank_values:
                nv.append(u'')
            else:
                continue
        if len(nv[1]) or keep_blank_values:
            name = nv[0].replace(u'+', u' ')
            name = unquote(name, encoding=encoding, errors=errors)
            name = _coerce_result(name)
            value = nv[1].replace(u'+', u' ')
            value = unquote(value, encoding=encoding, errors=errors)
            value = _coerce_result(value)
            r.append((name, value))

    return r


def unquote_plus(string, encoding=u'utf-8', errors=u'replace'):
    string = string.replace(u'+', u' ')
    return unquote(string, encoding, errors)


_ALWAYS_SAFE = frozenset(bytes('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-'))
_ALWAYS_SAFE_BYTES = bytes(_ALWAYS_SAFE)
_safe_quoters = {}

class Quoter(collections.defaultdict):

    def __init__(self, safe):
        self.safe = _ALWAYS_SAFE.union(bytes(safe))

    def __repr__(self):
        return u'<Quoter %r>' % dict(self)

    def __missing__(self, b):
        res = chr(b) if b in self.safe else u'%{0:02X}'.format(b)
        self[b] = res
        return res


def quote(string, safe=u'/', encoding=None, errors=None):
    if isinstance(string, str):
        if not string:
            return string
        if encoding is None:
            encoding = u'utf-8'
        if errors is None:
            errors = u'strict'
        string = string.encode(encoding, errors)
    else:
        if encoding is not None:
            raise TypeError(u"quote() doesn't support 'encoding' for bytes")
        if errors is not None:
            raise TypeError(u"quote() doesn't support 'errors' for bytes")
    return quote_from_bytes(string, safe)


def quote_plus(string, safe=u'', encoding=None, errors=None):
    if isinstance(string, str) and u' ' not in string or isinstance(string, bytes) and ' ' not in string:
        return quote(string, safe, encoding, errors)
    if isinstance(safe, str):
        space = str(u' ')
    else:
        space = bytes(' ')
    string = quote(string, safe + space, encoding, errors)
    return string.replace(u' ', u'+')


def quote_from_bytes(bs, safe=u'/'):
    if not isinstance(bs, (bytes, bytearray)):
        raise TypeError(u'quote_from_bytes() expected bytes')
    if not bs:
        return str(u'')
    bs = bytes(bs)
    if isinstance(safe, str):
        safe = str(safe).encode(u'ascii', u'ignore')
    else:
        safe = bytes(safe)
        safe = bytes([ c for c in safe if c < 128 ])
    if not bs.rstrip(_ALWAYS_SAFE_BYTES + safe):
        return bs.decode()
    try:
        quoter = _safe_quoters[safe]
    except KeyError:
        _safe_quoters[safe] = quoter = Quoter(safe).__getitem__

    return str(u'').join([ quoter(char) for char in bs ])


def urlencode(query, doseq=False, safe=u'', encoding=None, errors=None):
    if hasattr(query, u'items'):
        query = query.items()
    else:
        try:
            if len(query) and not isinstance(query[0], tuple):
                raise TypeError
        except TypeError:
            ty, va, tb = sys.exc_info()
            raise_with_traceback(TypeError(u'not a valid non-string sequence or mapping object'), tb)

    l = []
    if not doseq:
        for k, v in query:
            if isinstance(k, bytes):
                k = quote_plus(k, safe)
            else:
                k = quote_plus(str(k), safe, encoding, errors)
            if isinstance(v, bytes):
                v = quote_plus(v, safe)
            else:
                v = quote_plus(str(v), safe, encoding, errors)
            l.append(k + u'=' + v)

    else:
        for k, v in query:
            if isinstance(k, bytes):
                k = quote_plus(k, safe)
            else:
                k = quote_plus(str(k), safe, encoding, errors)
            if isinstance(v, bytes):
                v = quote_plus(v, safe)
                l.append(k + u'=' + v)
            if isinstance(v, str):
                v = quote_plus(v, safe, encoding, errors)
                l.append(k + u'=' + v)
            try:
                x = len(v)
            except TypeError:
                v = quote_plus(str(v), safe, encoding, errors)
                l.append(k + u'=' + v)
            else:
                for elt in v:
                    if isinstance(elt, bytes):
                        elt = quote_plus(elt, safe)
                    else:
                        elt = quote_plus(str(elt), safe, encoding, errors)
                    l.append(k + u'=' + elt)

    return str(u'&').join(l)


def to_bytes(url):
    if isinstance(url, str):
        try:
            url = url.encode(u'ASCII').decode()
        except UnicodeError:
            raise UnicodeError(u'URL ' + repr(url) + u' contains non-ASCII characters')

    return url


def unwrap(url):
    url = str(url).strip()
    if url[:1] == u'<' and url[-1:] == u'>':
        url = url[1:-1].strip()
    if url[:4] == u'URL:':
        url = url[4:].strip()
    return url


_typeprog = None

def splittype(url):
    global _typeprog
    if _typeprog is None:
        import re
        _typeprog = re.compile(u'^([^/:]+):')
    match = _typeprog.match(url)
    if match:
        scheme = match.group(1)
        return (scheme.lower(), url[len(scheme) + 1:])
    else:
        return (None, url)


_hostprog = None

def splithost(url):
    global _hostprog
    if _hostprog is None:
        import re
        _hostprog = re.compile(u'^//([^/?]*)(.*)$')
    match = _hostprog.match(url)
    if match:
        host_port = match.group(1)
        path = match.group(2)
        if path and not path.startswith(u'/'):
            path = u'/' + path
        return (host_port, path)
    else:
        return (None, url)


_userprog = None

def splituser(host):
    global _userprog
    if _userprog is None:
        import re
        _userprog = re.compile(u'^(.*)@(.*)$')
    match = _userprog.match(host)
    return match.group(1, 2) if match else (None, host)


_passwdprog = None

def splitpasswd(user):
    global _passwdprog
    if _passwdprog is None:
        import re
        _passwdprog = re.compile(u'^([^:]*):(.*)$', re.S)
    match = _passwdprog.match(user)
    return match.group(1, 2) if match else (user, None)


_portprog = None

def splitport(host):
    global _portprog
    if _portprog is None:
        import re
        _portprog = re.compile(u'^(.*):([0-9]+)$')
    match = _portprog.match(host)
    return match.group(1, 2) if match else (host, None)


_nportprog = None

def splitnport(host, defport=-1):
    global _nportprog
    if _nportprog is None:
        import re
        _nportprog = re.compile(u'^(.*):(.*)$')
    match = _nportprog.match(host)
    if match:
        host, port = match.group(1, 2)
        try:
            if not port:
                raise ValueError(u'no digits')
            nport = int(port)
        except ValueError:
            nport = None

        return (host, nport)
    else:
        return (host, defport)


_queryprog = None

def splitquery(url):
    global _queryprog
    if _queryprog is None:
        import re
        _queryprog = re.compile(u'^(.*)\\?([^?]*)$')
    match = _queryprog.match(url)
    return match.group(1, 2) if match else (url, None)


_tagprog = None

def splittag(url):
    global _tagprog
    if _tagprog is None:
        import re
        _tagprog = re.compile(u'^(.*)#([^#]*)$')
    match = _tagprog.match(url)
    return match.group(1, 2) if match else (url, None)


def splitattr(url):
    words = url.split(u';')
    return (words[0], words[1:])


_valueprog = None

def splitvalue(attr):
    global _valueprog
    if _valueprog is None:
        import re
        _valueprog = re.compile(u'^([^=]*)=(.*)$')
    match = _valueprog.match(attr)
    return match.group(1, 2) if match else (attr, None)
