# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/http/cookies.py
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import chr, dict, int, str
from future.utils import PY2, as_native_str
import re
if PY2:
    re.ASCII = 0
import string
__all__ = [u'CookieError', u'BaseCookie', u'SimpleCookie']
_nulljoin = u''.join
_semispacejoin = u'; '.join
_spacejoin = u' '.join

class CookieError(Exception):
    pass


_LegalChars = string.ascii_letters + string.digits + u"!#$%&'*+-.^_`|~:"
_Translator = {u'\x00': u'\\000',
 u'\x01': u'\\001',
 u'\x02': u'\\002',
 u'\x03': u'\\003',
 u'\x04': u'\\004',
 u'\x05': u'\\005',
 u'\x06': u'\\006',
 u'\x07': u'\\007',
 u'\x08': u'\\010',
 u'\t': u'\\011',
 u'\n': u'\\012',
 u'\x0b': u'\\013',
 u'\x0c': u'\\014',
 u'\r': u'\\015',
 u'\x0e': u'\\016',
 u'\x0f': u'\\017',
 u'\x10': u'\\020',
 u'\x11': u'\\021',
 u'\x12': u'\\022',
 u'\x13': u'\\023',
 u'\x14': u'\\024',
 u'\x15': u'\\025',
 u'\x16': u'\\026',
 u'\x17': u'\\027',
 u'\x18': u'\\030',
 u'\x19': u'\\031',
 u'\x1a': u'\\032',
 u'\x1b': u'\\033',
 u'\x1c': u'\\034',
 u'\x1d': u'\\035',
 u'\x1e': u'\\036',
 u'\x1f': u'\\037',
 u',': u'\\054',
 u';': u'\\073',
 u'"': u'\\"',
 u'\\': u'\\\\',
 u'\x7f': u'\\177',
 u'\x80': u'\\200',
 u'\x81': u'\\201',
 u'\x82': u'\\202',
 u'\x83': u'\\203',
 u'\x84': u'\\204',
 u'\x85': u'\\205',
 u'\x86': u'\\206',
 u'\x87': u'\\207',
 u'\x88': u'\\210',
 u'\x89': u'\\211',
 u'\x8a': u'\\212',
 u'\x8b': u'\\213',
 u'\x8c': u'\\214',
 u'\x8d': u'\\215',
 u'\x8e': u'\\216',
 u'\x8f': u'\\217',
 u'\x90': u'\\220',
 u'\x91': u'\\221',
 u'\x92': u'\\222',
 u'\x93': u'\\223',
 u'\x94': u'\\224',
 u'\x95': u'\\225',
 u'\x96': u'\\226',
 u'\x97': u'\\227',
 u'\x98': u'\\230',
 u'\x99': u'\\231',
 u'\x9a': u'\\232',
 u'\x9b': u'\\233',
 u'\x9c': u'\\234',
 u'\x9d': u'\\235',
 u'\x9e': u'\\236',
 u'\x9f': u'\\237',
 u'\xa0': u'\\240',
 u'\xa1': u'\\241',
 u'\xa2': u'\\242',
 u'\xa3': u'\\243',
 u'\xa4': u'\\244',
 u'\xa5': u'\\245',
 u'\xa6': u'\\246',
 u'\xa7': u'\\247',
 u'\xa8': u'\\250',
 u'\xa9': u'\\251',
 u'\xaa': u'\\252',
 u'\xab': u'\\253',
 u'\xac': u'\\254',
 u'\xad': u'\\255',
 u'\xae': u'\\256',
 u'\xaf': u'\\257',
 u'\xb0': u'\\260',
 u'\xb1': u'\\261',
 u'\xb2': u'\\262',
 u'\xb3': u'\\263',
 u'\xb4': u'\\264',
 u'\xb5': u'\\265',
 u'\xb6': u'\\266',
 u'\xb7': u'\\267',
 u'\xb8': u'\\270',
 u'\xb9': u'\\271',
 u'\xba': u'\\272',
 u'\xbb': u'\\273',
 u'\xbc': u'\\274',
 u'\xbd': u'\\275',
 u'\xbe': u'\\276',
 u'\xbf': u'\\277',
 u'\xc0': u'\\300',
 u'\xc1': u'\\301',
 u'\xc2': u'\\302',
 u'\xc3': u'\\303',
 u'\xc4': u'\\304',
 u'\xc5': u'\\305',
 u'\xc6': u'\\306',
 u'\xc7': u'\\307',
 u'\xc8': u'\\310',
 u'\xc9': u'\\311',
 u'\xca': u'\\312',
 u'\xcb': u'\\313',
 u'\xcc': u'\\314',
 u'\xcd': u'\\315',
 u'\xce': u'\\316',
 u'\xcf': u'\\317',
 u'\xd0': u'\\320',
 u'\xd1': u'\\321',
 u'\xd2': u'\\322',
 u'\xd3': u'\\323',
 u'\xd4': u'\\324',
 u'\xd5': u'\\325',
 u'\xd6': u'\\326',
 u'\xd7': u'\\327',
 u'\xd8': u'\\330',
 u'\xd9': u'\\331',
 u'\xda': u'\\332',
 u'\xdb': u'\\333',
 u'\xdc': u'\\334',
 u'\xdd': u'\\335',
 u'\xde': u'\\336',
 u'\xdf': u'\\337',
 u'\xe0': u'\\340',
 u'\xe1': u'\\341',
 u'\xe2': u'\\342',
 u'\xe3': u'\\343',
 u'\xe4': u'\\344',
 u'\xe5': u'\\345',
 u'\xe6': u'\\346',
 u'\xe7': u'\\347',
 u'\xe8': u'\\350',
 u'\xe9': u'\\351',
 u'\xea': u'\\352',
 u'\xeb': u'\\353',
 u'\xec': u'\\354',
 u'\xed': u'\\355',
 u'\xee': u'\\356',
 u'\xef': u'\\357',
 u'\xf0': u'\\360',
 u'\xf1': u'\\361',
 u'\xf2': u'\\362',
 u'\xf3': u'\\363',
 u'\xf4': u'\\364',
 u'\xf5': u'\\365',
 u'\xf6': u'\\366',
 u'\xf7': u'\\367',
 u'\xf8': u'\\370',
 u'\xf9': u'\\371',
 u'\xfa': u'\\372',
 u'\xfb': u'\\373',
 u'\xfc': u'\\374',
 u'\xfd': u'\\375',
 u'\xfe': u'\\376',
 u'\xff': u'\\377'}

def _quote(str, LegalChars=_LegalChars):
    if all((c in LegalChars for c in str)):
        return str
    else:
        return u'"' + _nulljoin((_Translator.get(s, s) for s in str)) + u'"'


_OctalPatt = re.compile(u'\\\\[0-3][0-7][0-7]')
_QuotePatt = re.compile(u'[\\\\].')

def _unquote(mystr):
    if len(mystr) < 2:
        return mystr
    if mystr[0] != u'"' or mystr[-1] != u'"':
        return mystr
    mystr = mystr[1:-1]
    i = 0
    n = len(mystr)
    res = []
    while 0 <= i < n:
        o_match = _OctalPatt.search(mystr, i)
        q_match = _QuotePatt.search(mystr, i)
        if not o_match and not q_match:
            res.append(mystr[i:])
            break
        j = k = -1
        if o_match:
            j = o_match.start(0)
        if q_match:
            k = q_match.start(0)
        if q_match and (not o_match or k < j):
            res.append(mystr[i:k])
            res.append(mystr[k + 1])
            i = k + 2
        res.append(mystr[i:j])
        res.append(chr(int(mystr[j + 1:j + 4], 8)))
        i = j + 4

    return _nulljoin(res)


_weekdayname = [u'Mon',
 u'Tue',
 u'Wed',
 u'Thu',
 u'Fri',
 u'Sat',
 u'Sun']
_monthname = [None,
 u'Jan',
 u'Feb',
 u'Mar',
 u'Apr',
 u'May',
 u'Jun',
 u'Jul',
 u'Aug',
 u'Sep',
 u'Oct',
 u'Nov',
 u'Dec']

def _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):
    from time import gmtime, time
    now = time()
    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)
    return u'%s, %02d %3s %4d %02d:%02d:%02d GMT' % (weekdayname[wd],
     day,
     monthname[month],
     year,
     hh,
     mm,
     ss)


class Morsel(dict):
    _reserved = {u'expires': u'expires',
     u'path': u'Path',
     u'comment': u'Comment',
     u'domain': u'Domain',
     u'max-age': u'Max-Age',
     u'secure': u'secure',
     u'httponly': u'httponly',
     u'version': u'Version'}
    _flags = set([u'secure', u'httponly'])

    def __init__(self):
        self.key = self.value = self.coded_value = None
        for key in self._reserved:
            dict.__setitem__(self, key, u'')

        return

    def __setitem__(self, K, V):
        K = K.lower()
        if K not in self._reserved:
            raise CookieError(u'Invalid Attribute %s' % K)
        dict.__setitem__(self, K, V)

    def isReservedKey(self, K):
        return K.lower() in self._reserved

    def set(self, key, val, coded_val, LegalChars=_LegalChars):
        if key.lower() in self._reserved:
            raise CookieError(u'Attempt to set a reserved key: %s' % key)
        if any((c not in LegalChars for c in key)):
            raise CookieError(u'Illegal key value: %s' % key)
        self.key = key
        self.value = val
        self.coded_value = coded_val

    def output(self, attrs=None, header=u'Set-Cookie:'):
        return u'%s %s' % (header, self.OutputString(attrs))

    __str__ = output

    @as_native_str()
    def __repr__(self):
        if PY2 and isinstance(self.value, unicode):
            val = str(self.value)
        else:
            val = self.value
        return u'<%s: %s=%s>' % (self.__class__.__name__, str(self.key), repr(val))

    def js_output(self, attrs=None):
        return u'\n        <script type="text/javascript">\n        <!-- begin hiding\n        document.cookie = "%s";\n        // end hiding -->\n        </script>\n        ' % self.OutputString(attrs).replace(u'"', u'\\"')

    def OutputString(self, attrs=None):
        result = []
        append = result.append
        append(u'%s=%s' % (self.key, self.coded_value))
        if attrs is None:
            attrs = self._reserved
        items = sorted(self.items())
        for key, value in items:
            if value == u'':
                continue
            if key not in attrs:
                continue
            if key == u'expires' and isinstance(value, int):
                append(u'%s=%s' % (self._reserved[key], _getdate(value)))
            if key == u'max-age' and isinstance(value, int):
                append(u'%s=%d' % (self._reserved[key], value))
            if key == u'secure':
                append(str(self._reserved[key]))
            if key == u'httponly':
                append(str(self._reserved[key]))
            append(u'%s=%s' % (self._reserved[key], value))

        return _semispacejoin(result)


_LegalCharsPatt = u"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=]"
_CookiePattern = re.compile(u"\n    (?x)                           # This is a verbose pattern\n    (?P<key>                       # Start of group 'key'\n    " + _LegalCharsPatt + u'+?   # Any word of at least one letter\n    )                              # End of group \'key\'\n    (                              # Optional group: there may not be a value.\n    \\s*=\\s*                          # Equal Sign\n    (?P<val>                         # Start of group \'val\'\n    "(?:[^\\\\"]|\\\\.)*"                  # Any doublequoted string\n    |                                  # or\n    \\w{3},\\s[\\w\\d\\s-]{9,11}\\s[\\d:]{8}\\sGMT  # Special case for "expires" attr\n    |                                  # or\n    ' + _LegalCharsPatt + u"*      # Any word or empty string\n    )                                # End of group 'val'\n    )?                             # End of optional value group\n    \\s*                            # Any number of spaces.\n    (\\s+|;|$)                      # Ending either at space, semicolon, or EOS.\n    ", re.ASCII)

class BaseCookie(dict):

    def value_decode(self, val):
        return (val, val)

    def value_encode(self, val):
        strval = str(val)
        return (strval, strval)

    def __init__(self, input=None):
        if input:
            self.load(input)

    def __set(self, key, real_value, coded_value):
        M = self.get(key, Morsel())
        M.set(key, real_value, coded_value)
        dict.__setitem__(self, key, M)

    def __setitem__(self, key, value):
        rval, cval = self.value_encode(value)
        self.__set(key, rval, cval)

    def output(self, attrs=None, header=u'Set-Cookie:', sep=u'\r\n'):
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.output(attrs, header))

        return sep.join(result)

    __str__ = output

    @as_native_str()
    def __repr__(self):
        l = []
        items = sorted(self.items())
        for key, value in items:
            if PY2 and isinstance(value.value, unicode):
                val = str(value.value)
            else:
                val = value.value
            l.append(u'%s=%s' % (str(key), repr(val)))

        return u'<%s: %s>' % (self.__class__.__name__, _spacejoin(l))

    def js_output(self, attrs=None):
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.js_output(attrs))

        return _nulljoin(result)

    def load(self, rawdata):
        if isinstance(rawdata, str):
            self.__parse_string(rawdata)
        else:
            for key, value in rawdata.items():
                self[key] = value

    def __parse_string(self, mystr, patt=_CookiePattern):
        i = 0
        n = len(mystr)
        M = None
        while 0 <= i < n:
            match = patt.search(mystr, i)
            if not match:
                break
            key, value = match.group(u'key'), match.group(u'val')
            i = match.end(0)
            if key[0] == u'$':
                if M:
                    M[key[1:]] = value
            if key.lower() in Morsel._reserved:
                if M:
                    if value is None:
                        if key.lower() in Morsel._flags:
                            M[key] = True
                    else:
                        M[key] = _unquote(value)
            if value is not None:
                rval, cval = self.value_decode(value)
                self.__set(key, rval, cval)
                M = self[key]

        return


class SimpleCookie(BaseCookie):

    def value_decode(self, val):
        return (_unquote(val), val)

    def value_encode(self, val):
        strval = str(val)
        return (strval, _quote(strval))
