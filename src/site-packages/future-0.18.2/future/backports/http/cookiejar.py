# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/http/cookiejar.py
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import filter, int, map, open, str
from future.utils import as_native_str, PY2
__all__ = [u'Cookie',
 u'CookieJar',
 u'CookiePolicy',
 u'DefaultCookiePolicy',
 u'FileCookieJar',
 u'LWPCookieJar',
 u'LoadError',
 u'MozillaCookieJar']
import copy
import datetime
import re
if PY2:
    re.ASCII = 0
import time
from future.backports.urllib.parse import urlparse, urlsplit, quote
from future.backports.http.client import HTTP_PORT
try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading

from calendar import timegm
debug = False
logger = None

def _debug(*args):
    global logger
    if not debug:
        return
    if not logger:
        import logging
        logger = logging.getLogger(u'http.cookiejar')
    return logger.debug(*args)


DEFAULT_HTTP_PORT = str(HTTP_PORT)
MISSING_FILENAME_TEXT = u'a filename was not supplied (nor was the CookieJar instance initialised with one)'

def _warn_unhandled_exception():
    import io, warnings, traceback
    f = io.StringIO()
    traceback.print_exc(None, f)
    msg = f.getvalue()
    warnings.warn(u'http.cookiejar bug!\n%s' % msg, stacklevel=2)
    return


EPOCH_YEAR = 1970

def _timegm(tt):
    year, month, mday, hour, min, sec = tt[:6]
    if ((year >= EPOCH_YEAR and 1 <= month <= 12 and 1) <= mday <= 31 and 0 <= hour <= 24 and 0) <= min <= 59:
        return 0 <= sec <= 61 and timegm(tt)
    else:
        return None
        return None


DAYS = [u'Mon',
 u'Tue',
 u'Wed',
 u'Thu',
 u'Fri',
 u'Sat',
 u'Sun']
MONTHS = [u'Jan',
 u'Feb',
 u'Mar',
 u'Apr',
 u'May',
 u'Jun',
 u'Jul',
 u'Aug',
 u'Sep',
 u'Oct',
 u'Nov',
 u'Dec']
MONTHS_LOWER = []
for month in MONTHS:
    MONTHS_LOWER.append(month.lower())

def time2isoz(t=None):
    if t is None:
        dt = datetime.datetime.utcnow()
    else:
        dt = datetime.datetime.utcfromtimestamp(t)
    return u'%04d-%02d-%02d %02d:%02d:%02dZ' % (dt.year,
     dt.month,
     dt.day,
     dt.hour,
     dt.minute,
     dt.second)


def time2netscape(t=None):
    if t is None:
        dt = datetime.datetime.utcnow()
    else:
        dt = datetime.datetime.utcfromtimestamp(t)
    return u'%s %02d-%s-%04d %02d:%02d:%02d GMT' % (DAYS[dt.weekday()],
     dt.day,
     MONTHS[dt.month - 1],
     dt.year,
     dt.hour,
     dt.minute,
     dt.second)


UTC_ZONES = {u'GMT': None,
 u'UTC': None,
 u'UT': None,
 u'Z': None}
TIMEZONE_RE = re.compile(u'^([-+])?(\\d\\d?):?(\\d\\d)?$', re.ASCII)

def offset_from_tz_string(tz):
    offset = None
    if tz in UTC_ZONES:
        offset = 0
    else:
        m = TIMEZONE_RE.search(tz)
        if m:
            offset = 3600 * int(m.group(2))
            if m.group(3):
                offset = offset + 60 * int(m.group(3))
            if m.group(1) == u'-':
                offset = -offset
    return offset


def _str2time(day, mon, yr, hr, min, sec, tz):
    try:
        mon = MONTHS_LOWER.index(mon.lower()) + 1
    except ValueError:
        try:
            imon = int(mon)
        except ValueError:
            return

        if 1 <= imon <= 12:
            mon = imon
        else:
            return

    if hr is None:
        hr = 0
    if min is None:
        min = 0
    if sec is None:
        sec = 0
    yr = int(yr)
    day = int(day)
    hr = int(hr)
    min = int(min)
    sec = int(sec)
    if yr < 1000:
        cur_yr = time.localtime(time.time())[0]
        m = cur_yr % 100
        tmp = yr
        yr = yr + cur_yr - m
        m = m - tmp
        if abs(m) > 50:
            if m > 0:
                yr = yr + 100
            else:
                yr = yr - 100
    t = _timegm((yr,
     mon,
     day,
     hr,
     min,
     sec,
     tz))
    if t is not None:
        if tz is None:
            tz = u'UTC'
        tz = tz.upper()
        offset = offset_from_tz_string(tz)
        if offset is None:
            return
        t = t - offset
    return t


STRICT_DATE_RE = re.compile(u'^[SMTWF][a-z][a-z], (\\d\\d) ([JFMASOND][a-z][a-z]) (\\d\\d\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$', re.ASCII)
WEEKDAY_RE = re.compile(u'^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\\s*', re.I | re.ASCII)
LOOSE_HTTP_DATE_RE = re.compile(u'^\n    (\\d\\d?)            # day\n       (?:\\s+|[-\\/])\n    (\\w+)              # month\n        (?:\\s+|[-\\/])\n    (\\d+)              # year\n    (?:\n          (?:\\s+|:)    # separator before clock\n       (\\d\\d?):(\\d\\d)  # hour:min\n       (?::(\\d\\d))?    # optional seconds\n    )?                 # optional clock\n       \\s*\n    ([-+]?\\d{2,4}|(?![APap][Mm]\\b)[A-Za-z]+)? # timezone\n       \\s*\n    (?:\\(\\w+\\))?       # ASCII representation of timezone in parens.\n       \\s*$', re.X | re.ASCII)

def http2time(text):
    m = STRICT_DATE_RE.search(text)
    if m:
        g = m.groups()
        mon = MONTHS_LOWER.index(g[1].lower()) + 1
        tt = (int(g[2]),
         mon,
         int(g[0]),
         int(g[3]),
         int(g[4]),
         float(g[5]))
        return _timegm(tt)
    else:
        text = text.lstrip()
        text = WEEKDAY_RE.sub(u'', text, 1)
        day, mon, yr, hr, min, sec, tz = [None] * 7
        m = LOOSE_HTTP_DATE_RE.search(text)
        if m is not None:
            day, mon, yr, hr, min, sec, tz = m.groups()
        else:
            return
        return _str2time(day, mon, yr, hr, min, sec, tz)


ISO_DATE_RE = re.compile(u'^\n    (\\d{4})              # year\n       [-\\/]?\n    (\\d\\d?)              # numerical month\n       [-\\/]?\n    (\\d\\d?)              # day\n   (?:\n         (?:\\s+|[-:Tt])  # separator before clock\n      (\\d\\d?):?(\\d\\d)    # hour:min\n      (?::?(\\d\\d(?:\\.\\d*)?))?  # optional seconds (and fractional)\n   )?                    # optional clock\n      \\s*\n   ([-+]?\\d\\d?:?(:?\\d\\d)?\n    |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)\n      \\s*$', re.X | re.ASCII)

def iso2time(text):
    text = text.lstrip()
    day, mon, yr, hr, min, sec, tz = [None] * 7
    m = ISO_DATE_RE.search(text)
    if m is not None:
        yr, mon, day, hr, min, sec, tz, _ = m.groups()
    else:
        return
    return _str2time(day, mon, yr, hr, min, sec, tz)


def unmatched(match):
    start, end = match.span(0)
    return match.string[:start] + match.string[end:]


HEADER_TOKEN_RE = re.compile(u'^\\s*([^=\\s;,]+)')
HEADER_QUOTED_VALUE_RE = re.compile(u'^\\s*=\\s*\\"([^\\"\\\\]*(?:\\\\.[^\\"\\\\]*)*)\\"')
HEADER_VALUE_RE = re.compile(u'^\\s*=\\s*([^\\s;,]*)')
HEADER_ESCAPE_RE = re.compile(u'\\\\(.)')

def split_header_words(header_values):
    result = []
    for text in header_values:
        orig_text = text
        pairs = []
        while text:
            m = HEADER_TOKEN_RE.search(text)
            if m:
                text = unmatched(m)
                name = m.group(1)
                m = HEADER_QUOTED_VALUE_RE.search(text)
                if m:
                    text = unmatched(m)
                    value = m.group(1)
                    value = HEADER_ESCAPE_RE.sub(u'\\1', value)
                else:
                    m = HEADER_VALUE_RE.search(text)
                    if m:
                        text = unmatched(m)
                        value = m.group(1)
                        value = value.rstrip()
                    else:
                        value = None
                pairs.append((name, value))
            if text.lstrip().startswith(u','):
                text = text.lstrip()[1:]
                if pairs:
                    result.append(pairs)
                pairs = []
            non_junk, nr_junk_chars = re.subn(u'^[=\\s;]*', u'', text)
            text = non_junk

        if pairs:
            result.append(pairs)

    return result


HEADER_JOIN_ESCAPE_RE = re.compile(u'([\\"\\\\])')

def join_header_words(lists):
    headers = []
    for pairs in lists:
        attr = []
        for k, v in pairs:
            if v is not None:
                if not re.search(u'^\\w+$', v):
                    v = HEADER_JOIN_ESCAPE_RE.sub(u'\\\\\\1', v)
                    v = u'"%s"' % v
                k = u'%s=%s' % (k, v)
            attr.append(k)

        if attr:
            headers.append(u'; '.join(attr))

    return u', '.join(headers)


def strip_quotes(text):
    if text.startswith(u'"'):
        text = text[1:]
    if text.endswith(u'"'):
        text = text[:-1]
    return text


def parse_ns_headers(ns_headers):
    known_attrs = (u'expires', u'domain', u'path', u'secure', u'version', u'port', u'max-age')
    result = []
    for ns_header in ns_headers:
        pairs = []
        version_set = False
        for ii, param in enumerate(re.split(u';\\s*', ns_header)):
            param = param.rstrip()
            if param == u'':
                continue
            if u'=' not in param:
                k, v = param, None
            else:
                k, v = re.split(u'\\s*=\\s*', param, 1)
                k = k.lstrip()
            if ii != 0:
                lc = k.lower()
                if lc in known_attrs:
                    k = lc
                if k == u'version':
                    v = strip_quotes(v)
                    version_set = True
                if k == u'expires':
                    v = http2time(strip_quotes(v))
            pairs.append((k, v))

        if pairs:
            if not version_set:
                pairs.append((u'version', u'0'))
            result.append(pairs)

    return result


IPV4_RE = re.compile(u'\\.\\d+$', re.ASCII)

def is_HDN(text):
    if IPV4_RE.search(text):
        return False
    if text == u'':
        return False
    return False if text[0] == u'.' or text[-1] == u'.' else True


def domain_match(A, B):
    A = A.lower()
    B = B.lower()
    if A == B:
        return True
    if not is_HDN(A):
        return False
    i = A.rfind(B)
    if i == -1 or i == 0:
        return False
    if not B.startswith(u'.'):
        return False
    return False if not is_HDN(B[1:]) else True


def liberal_is_HDN(text):
    return False if IPV4_RE.search(text) else True


def user_domain_match(A, B):
    A = A.lower()
    B = B.lower()
    if not (liberal_is_HDN(A) and liberal_is_HDN(B)):
        if A == B:
            return True
        return False
    initial_dot = B.startswith(u'.')
    if initial_dot and A.endswith(B):
        return True
    return True if not initial_dot and A == B else False


cut_port_re = re.compile(u':\\d+$', re.ASCII)

def request_host(request):
    url = request.get_full_url()
    host = urlparse(url)[1]
    if host == u'':
        host = request.get_header(u'Host', u'')
    host = cut_port_re.sub(u'', host, 1)
    return host.lower()


def eff_request_host(request):
    erhn = req_host = request_host(request)
    if req_host.find(u'.') == -1 and not IPV4_RE.search(req_host):
        erhn = req_host + u'.local'
    return (req_host, erhn)


def request_path(request):
    url = request.get_full_url()
    parts = urlsplit(url)
    path = escape_path(parts.path)
    if not path.startswith(u'/'):
        path = u'/' + path
    return path


def request_port(request):
    host = request.host
    i = host.find(u':')
    if i >= 0:
        port = host[i + 1:]
        try:
            int(port)
        except ValueError:
            _debug(u"nonnumeric port: '%s'", port)
            return None

    else:
        port = DEFAULT_HTTP_PORT
    return port


HTTP_PATH_SAFE = u"%/;:@&=+$,!~*'()"
ESCAPED_CHAR_RE = re.compile(u'%([0-9a-fA-F][0-9a-fA-F])')

def uppercase_escaped_char(match):
    return u'%%%s' % match.group(1).upper()


def escape_path(path):
    path = quote(path, HTTP_PATH_SAFE)
    path = ESCAPED_CHAR_RE.sub(uppercase_escaped_char, path)
    return path


def reach(h):
    i = h.find(u'.')
    if i >= 0:
        b = h[i + 1:]
        i = b.find(u'.')
        if is_HDN(h) and (i >= 0 or b == u'local'):
            return u'.' + b
    return h


def is_third_party(request):
    req_host = request_host(request)
    if not domain_match(req_host, reach(request.get_origin_req_host())):
        return True
    else:
        return False


class Cookie(object):

    def __init__(self, version, name, value, port, port_specified, domain, domain_specified, domain_initial_dot, path, path_specified, secure, expires, discard, comment, comment_url, rest, rfc2109=False):
        if version is not None:
            version = int(version)
        if expires is not None:
            expires = int(expires)
        if port is None and port_specified is True:
            raise ValueError(u'if port is None, port_specified must be false')
        self.version = version
        self.name = name
        self.value = value
        self.port = port
        self.port_specified = port_specified
        self.domain = domain.lower()
        self.domain_specified = domain_specified
        self.domain_initial_dot = domain_initial_dot
        self.path = path
        self.path_specified = path_specified
        self.secure = secure
        self.expires = expires
        self.discard = discard
        self.comment = comment
        self.comment_url = comment_url
        self.rfc2109 = rfc2109
        self._rest = copy.copy(rest)
        return

    def has_nonstandard_attr(self, name):
        return name in self._rest

    def get_nonstandard_attr(self, name, default=None):
        return self._rest.get(name, default)

    def set_nonstandard_attr(self, name, value):
        self._rest[name] = value

    def is_expired(self, now=None):
        if now is None:
            now = time.time()
        return True if self.expires is not None and self.expires <= now else False

    def __str__(self):
        if self.port is None:
            p = u''
        else:
            p = u':' + self.port
        limit = self.domain + p + self.path
        if self.value is not None:
            namevalue = u'%s=%s' % (self.name, self.value)
        else:
            namevalue = self.name
        return u'<Cookie %s for %s>' % (namevalue, limit)

    @as_native_str()
    def __repr__(self):
        args = []
        for name in (u'version', u'name', u'value', u'port', u'port_specified', u'domain', u'domain_specified', u'domain_initial_dot', u'path', u'path_specified', u'secure', u'expires', u'discard', u'comment', u'comment_url'):
            attr = getattr(self, name)
            if isinstance(attr, str):
                attr = str(attr)
            args.append(str(u'%s=%s') % (name, repr(attr)))

        args.append(u'rest=%s' % repr(self._rest))
        args.append(u'rfc2109=%s' % repr(self.rfc2109))
        return u'Cookie(%s)' % u', '.join(args)


class CookiePolicy(object):

    def set_ok(self, cookie, request):
        raise NotImplementedError()

    def return_ok(self, cookie, request):
        raise NotImplementedError()

    def domain_return_ok(self, domain, request):
        return True

    def path_return_ok(self, path, request):
        return True


class DefaultCookiePolicy(CookiePolicy):
    DomainStrictNoDots = 1
    DomainStrictNonDomain = 2
    DomainRFC2965Match = 4
    DomainLiberal = 0
    DomainStrict = DomainStrictNoDots | DomainStrictNonDomain

    def __init__(self, blocked_domains=None, allowed_domains=None, netscape=True, rfc2965=False, rfc2109_as_netscape=None, hide_cookie2=False, strict_domain=False, strict_rfc2965_unverifiable=True, strict_ns_unverifiable=False, strict_ns_domain=DomainLiberal, strict_ns_set_initial_dollar=False, strict_ns_set_path=False):
        self.netscape = netscape
        self.rfc2965 = rfc2965
        self.rfc2109_as_netscape = rfc2109_as_netscape
        self.hide_cookie2 = hide_cookie2
        self.strict_domain = strict_domain
        self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable
        self.strict_ns_unverifiable = strict_ns_unverifiable
        self.strict_ns_domain = strict_ns_domain
        self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar
        self.strict_ns_set_path = strict_ns_set_path
        if blocked_domains is not None:
            self._blocked_domains = tuple(blocked_domains)
        else:
            self._blocked_domains = ()
        if allowed_domains is not None:
            allowed_domains = tuple(allowed_domains)
        self._allowed_domains = allowed_domains
        return

    def blocked_domains(self):
        return self._blocked_domains

    def set_blocked_domains(self, blocked_domains):
        self._blocked_domains = tuple(blocked_domains)

    def is_blocked(self, domain):
        for blocked_domain in self._blocked_domains:
            if user_domain_match(domain, blocked_domain):
                return True

        return False

    def allowed_domains(self):
        return self._allowed_domains

    def set_allowed_domains(self, allowed_domains):
        if allowed_domains is not None:
            allowed_domains = tuple(allowed_domains)
        self._allowed_domains = allowed_domains
        return

    def is_not_allowed(self, domain):
        if self._allowed_domains is None:
            return False
        else:
            for allowed_domain in self._allowed_domains:
                if user_domain_match(domain, allowed_domain):
                    return False

            return True

    def set_ok(self, cookie, request):
        _debug(u' - checking cookie %s=%s', cookie.name, cookie.value)
        for n in (u'version', u'verifiability', u'name', u'path', u'domain', u'port'):
            fn_name = u'set_ok_' + n
            fn = getattr(self, fn_name)
            if not fn(cookie, request):
                return False

        return True

    def set_ok_version(self, cookie, request):
        if cookie.version is None:
            _debug(u'   Set-Cookie2 without version attribute (%s=%s)', cookie.name, cookie.value)
            return False
        elif cookie.version > 0 and not self.rfc2965:
            _debug(u'   RFC 2965 cookies are switched off')
            return False
        elif cookie.version == 0 and not self.netscape:
            _debug(u'   Netscape cookies are switched off')
            return False
        else:
            return True

    def set_ok_verifiability(self, cookie, request):
        if request.unverifiable and is_third_party(request):
            if cookie.version > 0 and self.strict_rfc2965_unverifiable:
                _debug(u'   third-party RFC 2965 cookie during unverifiable transaction')
                return False
            if cookie.version == 0 and self.strict_ns_unverifiable:
                _debug(u'   third-party Netscape cookie during unverifiable transaction')
                return False
        return True

    def set_ok_name(self, cookie, request):
        if cookie.version == 0 and self.strict_ns_set_initial_dollar and cookie.name.startswith(u'$'):
            _debug(u"   illegal name (starts with '$'): '%s'", cookie.name)
            return False
        return True

    def set_ok_path(self, cookie, request):
        if cookie.path_specified:
            req_path = request_path(request)
            if (cookie.version > 0 or cookie.version == 0 and self.strict_ns_set_path) and not req_path.startswith(cookie.path):
                _debug(u'   path attribute %s is not a prefix of request path %s', cookie.path, req_path)
                return False
        return True

    def set_ok_domain(self, cookie, request):
        if self.is_blocked(cookie.domain):
            _debug(u'   domain %s is in user block-list', cookie.domain)
            return False
        if self.is_not_allowed(cookie.domain):
            _debug(u'   domain %s is not in user allow-list', cookie.domain)
            return False
        if cookie.domain_specified:
            req_host, erhn = eff_request_host(request)
            domain = cookie.domain
            if self.strict_domain and domain.count(u'.') >= 2:
                i = domain.rfind(u'.')
                j = domain.rfind(u'.', 0, i)
                if j == 0:
                    tld = domain[i + 1:]
                    sld = domain[j + 1:i]
                    if sld.lower() in (u'co', u'ac', u'com', u'edu', u'org', u'net', u'gov', u'mil', u'int', u'aero', u'biz', u'cat', u'coop', u'info', u'jobs', u'mobi', u'museum', u'name', u'pro', u'travel', u'eu') and len(tld) == 2:
                        _debug(u'   country-code second level domain %s', domain)
                        return False
            if domain.startswith(u'.'):
                undotted_domain = domain[1:]
            else:
                undotted_domain = domain
            embedded_dots = undotted_domain.find(u'.') >= 0
            if not embedded_dots and domain != u'.local':
                _debug(u'   non-local domain %s contains no embedded dot', domain)
                return False
            if cookie.version == 0 and not erhn.endswith(domain) and not erhn.startswith(u'.'):
                if not (u'.' + erhn).endswith(domain):
                    _debug(u'   effective request-host %s (even with added initial dot) does not end with %s', erhn, domain)
                    return False
            if cookie.version > 0 or self.strict_ns_domain & self.DomainRFC2965Match:
                if not domain_match(erhn, domain):
                    _debug(u'   effective request-host %s does not domain-match %s', erhn, domain)
                    return False
            if cookie.version > 0 or self.strict_ns_domain & self.DomainStrictNoDots:
                host_prefix = req_host[:-len(domain)]
                if host_prefix.find(u'.') >= 0 and not IPV4_RE.search(req_host):
                    _debug(u'   host prefix %s for domain %s contains a dot', host_prefix, domain)
                    return False
        return True

    def set_ok_port(self, cookie, request):
        if cookie.port_specified:
            req_port = request_port(request)
            if req_port is None:
                req_port = u'80'
            else:
                req_port = str(req_port)
            for p in cookie.port.split(u','):
                try:
                    int(p)
                except ValueError:
                    _debug(u'   bad port %s (not numeric)', p)
                    return False

                if p == req_port:
                    break
            else:
                _debug(u'   request port (%s) not found in %s', req_port, cookie.port)
                return False

        return True

    def return_ok(self, cookie, request):
        _debug(u' - checking cookie %s=%s', cookie.name, cookie.value)
        for n in (u'version', u'verifiability', u'secure', u'expires', u'port', u'domain'):
            fn_name = u'return_ok_' + n
            fn = getattr(self, fn_name)
            if not fn(cookie, request):
                return False

        return True

    def return_ok_version(self, cookie, request):
        if cookie.version > 0 and not self.rfc2965:
            _debug(u'   RFC 2965 cookies are switched off')
            return False
        if cookie.version == 0 and not self.netscape:
            _debug(u'   Netscape cookies are switched off')
            return False
        return True

    def return_ok_verifiability(self, cookie, request):
        if request.unverifiable and is_third_party(request):
            if cookie.version > 0 and self.strict_rfc2965_unverifiable:
                _debug(u'   third-party RFC 2965 cookie during unverifiable transaction')
                return False
            if cookie.version == 0 and self.strict_ns_unverifiable:
                _debug(u'   third-party Netscape cookie during unverifiable transaction')
                return False
        return True

    def return_ok_secure(self, cookie, request):
        if cookie.secure and request.type != u'https':
            _debug(u'   secure cookie with non-secure request')
            return False
        return True

    def return_ok_expires(self, cookie, request):
        if cookie.is_expired(self._now):
            _debug(u'   cookie expired')
            return False
        return True

    def return_ok_port(self, cookie, request):
        if cookie.port:
            req_port = request_port(request)
            if req_port is None:
                req_port = u'80'
            for p in cookie.port.split(u','):
                if p == req_port:
                    break
            else:
                _debug(u'   request port %s does not match cookie port %s', req_port, cookie.port)
                return False

        return True

    def return_ok_domain(self, cookie, request):
        req_host, erhn = eff_request_host(request)
        domain = cookie.domain
        if cookie.version == 0 and self.strict_ns_domain & self.DomainStrictNonDomain and not cookie.domain_specified and domain != erhn:
            _debug(u'   cookie with unspecified domain does not string-compare equal to request domain')
            return False
        if cookie.version > 0 and not domain_match(erhn, domain):
            _debug(u'   effective request-host name %s does not domain-match RFC 2965 cookie domain %s', erhn, domain)
            return False
        if cookie.version == 0 and not (u'.' + erhn).endswith(domain):
            _debug(u'   request-host %s does not match Netscape cookie domain %s', req_host, domain)
            return False
        return True

    def domain_return_ok(self, domain, request):
        req_host, erhn = eff_request_host(request)
        if not req_host.startswith(u'.'):
            req_host = u'.' + req_host
        if not erhn.startswith(u'.'):
            erhn = u'.' + erhn
        if not (req_host.endswith(domain) or erhn.endswith(domain)):
            return False
        if self.is_blocked(domain):
            _debug(u'   domain %s is in user block-list', domain)
            return False
        if self.is_not_allowed(domain):
            _debug(u'   domain %s is not in user allow-list', domain)
            return False
        return True

    def path_return_ok(self, path, request):
        _debug(u'- checking cookie path=%s', path)
        req_path = request_path(request)
        if not req_path.startswith(path):
            _debug(u'  %s does not path-match %s', req_path, path)
            return False
        return True


def vals_sorted_by_key(adict):
    keys = sorted(adict.keys())
    return map(adict.get, keys)


def deepvalues(mapping):
    values = vals_sorted_by_key(mapping)
    for obj in values:
        mapping = False
        try:
            obj.items
        except AttributeError:
            pass
        else:
            mapping = True
            for subobj in deepvalues(obj):
                yield subobj

        if not mapping:
            yield obj


class Absent(object):
    pass


class CookieJar(object):
    non_word_re = re.compile(u'\\W')
    quote_re = re.compile(u'([\\"\\\\])')
    strict_domain_re = re.compile(u'\\.?[^.]*')
    domain_re = re.compile(u'[^.]*')
    dots_re = re.compile(u'^\\.+')
    magic_re = re.compile(u'^\\#LWP-Cookies-(\\d+\\.\\d+)', re.ASCII)

    def __init__(self, policy=None):
        if policy is None:
            policy = DefaultCookiePolicy()
        self._policy = policy
        self._cookies_lock = _threading.RLock()
        self._cookies = {}
        return

    def set_policy(self, policy):
        self._policy = policy

    def _cookies_for_domain(self, domain, request):
        cookies = []
        if not self._policy.domain_return_ok(domain, request):
            return []
        _debug(u'Checking %s for cookies to return', domain)
        cookies_by_path = self._cookies[domain]
        for path in cookies_by_path.keys():
            if not self._policy.path_return_ok(path, request):
                continue
            cookies_by_name = cookies_by_path[path]
            for cookie in cookies_by_name.values():
                if not self._policy.return_ok(cookie, request):
                    _debug(u'   not returning cookie')
                    continue
                _debug(u"   it's a match")
                cookies.append(cookie)

        return cookies

    def _cookies_for_request(self, request):
        cookies = []
        for domain in self._cookies.keys():
            cookies.extend(self._cookies_for_domain(domain, request))

        return cookies

    def _cookie_attrs(self, cookies):
        cookies.sort(key=lambda a: len(a.path), reverse=True)
        version_set = False
        attrs = []
        for cookie in cookies:
            version = cookie.version
            if not version_set:
                version_set = True
                if version > 0:
                    attrs.append(u'$Version=%s' % version)
            if cookie.value is not None and self.non_word_re.search(cookie.value) and version > 0:
                value = self.quote_re.sub(u'\\\\\\1', cookie.value)
            else:
                value = cookie.value
            if cookie.value is None:
                attrs.append(cookie.name)
            else:
                attrs.append(u'%s=%s' % (cookie.name, value))
            if version > 0:
                if cookie.path_specified:
                    attrs.append(u'$Path="%s"' % cookie.path)
                if cookie.domain.startswith(u'.'):
                    domain = cookie.domain
                    if not cookie.domain_initial_dot and domain.startswith(u'.'):
                        domain = domain[1:]
                    attrs.append(u'$Domain="%s"' % domain)
                if cookie.port is not None:
                    p = u'$Port'
                    if cookie.port_specified:
                        p = p + u'="%s"' % cookie.port
                    attrs.append(p)

        return attrs

    def add_cookie_header(self, request):
        _debug(u'add_cookie_header')
        self._cookies_lock.acquire()
        try:
            self._policy._now = self._now = int(time.time())
            cookies = self._cookies_for_request(request)
            attrs = self._cookie_attrs(cookies)
            if attrs:
                if not request.has_header(u'Cookie'):
                    request.add_unredirected_header(u'Cookie', u'; '.join(attrs))
            if self._policy.rfc2965 and not self._policy.hide_cookie2 and not request.has_header(u'Cookie2'):
                for cookie in cookies:
                    if cookie.version != 1:
                        request.add_unredirected_header(u'Cookie2', u'$Version="1"')
                        break

        finally:
            self._cookies_lock.release()

        self.clear_expired_cookies()

    def _normalized_cookie_tuples(self, attrs_set):
        cookie_tuples = []
        boolean_attrs = (u'discard', u'secure')
        value_attrs = (u'version', u'expires', u'max-age', u'domain', u'path', u'port', u'comment', u'commenturl')
        for cookie_attrs in attrs_set:
            name, value = cookie_attrs[0]
            max_age_set = False
            bad_cookie = False
            standard = {}
            rest = {}
            for k, v in cookie_attrs[1:]:
                lc = k.lower()
                if lc in value_attrs or lc in boolean_attrs:
                    k = lc
                if k in boolean_attrs and v is None:
                    v = True
                if k in standard:
                    continue
                if k == u'domain':
                    if v is None:
                        _debug(u'   missing value for domain attribute')
                        bad_cookie = True
                        break
                    v = v.lower()
                if k == u'expires':
                    if max_age_set:
                        continue
                    if v is None:
                        _debug(u'   missing or invalid value for expires attribute: treating as session cookie')
                        continue
                if k == u'max-age':
                    max_age_set = True
                    try:
                        v = int(v)
                    except ValueError:
                        _debug(u'   missing or invalid (non-numeric) value for max-age attribute')
                        bad_cookie = True
                        break

                    k = u'expires'
                    v = self._now + v
                if k in value_attrs or k in boolean_attrs:
                    if v is None and k not in (u'port', u'comment', u'commenturl'):
                        _debug(u'   missing value for %s attribute' % k)
                        bad_cookie = True
                        break
                    standard[k] = v
                rest[k] = v

            if bad_cookie:
                continue
            cookie_tuples.append((name,
             value,
             standard,
             rest))

        return cookie_tuples

    def _cookie_from_cookie_tuple(self, tup, request):
        name, value, standard, rest = tup
        domain = standard.get(u'domain', Absent)
        path = standard.get(u'path', Absent)
        port = standard.get(u'port', Absent)
        expires = standard.get(u'expires', Absent)
        version = standard.get(u'version', None)
        if version is not None:
            try:
                version = int(version)
            except ValueError:
                return

        secure = standard.get(u'secure', False)
        discard = standard.get(u'discard', False)
        comment = standard.get(u'comment', None)
        comment_url = standard.get(u'commenturl', None)
        if path is not Absent and path != u'':
            path_specified = True
            path = escape_path(path)
        else:
            path_specified = False
            path = request_path(request)
            i = path.rfind(u'/')
            if i != -1:
                if version == 0:
                    path = path[:i]
                else:
                    path = path[:i + 1]
            if len(path) == 0:
                path = u'/'
        domain_specified = domain is not Absent
        domain_initial_dot = False
        if domain_specified:
            domain_initial_dot = bool(domain.startswith(u'.'))
        if domain is Absent:
            req_host, erhn = eff_request_host(request)
            domain = erhn
        elif not domain.startswith(u'.'):
            domain = u'.' + domain
        port_specified = False
        if port is not Absent:
            if port is None:
                port = request_port(request)
            else:
                port_specified = True
                port = re.sub(u'\\s+', u'', port)
        else:
            port = None
        if expires is Absent:
            expires = None
            discard = True
        elif expires <= self._now:
            try:
                self.clear(domain, path, name)
            except KeyError:
                pass

            _debug(u"Expiring cookie, domain='%s', path='%s', name='%s'", domain, path, name)
            return
        return Cookie(version, name, value, port, port_specified, domain, domain_specified, domain_initial_dot, path, path_specified, secure, expires, discard, comment, comment_url, rest)

    def _cookies_from_attrs_set(self, attrs_set, request):
        cookie_tuples = self._normalized_cookie_tuples(attrs_set)
        cookies = []
        for tup in cookie_tuples:
            cookie = self._cookie_from_cookie_tuple(tup, request)
            if cookie:
                cookies.append(cookie)

        return cookies

    def _process_rfc2109_cookies(self, cookies):
        rfc2109_as_ns = getattr(self._policy, u'rfc2109_as_netscape', None)
        if rfc2109_as_ns is None:
            rfc2109_as_ns = not self._policy.rfc2965
        for cookie in cookies:
            if cookie.version == 1:
                cookie.rfc2109 = True
                if rfc2109_as_ns:
                    cookie.version = 0

        return

    def make_cookies(self, response, request):
        headers = response.info()
        rfc2965_hdrs = headers.get_all(u'Set-Cookie2', [])
        ns_hdrs = headers.get_all(u'Set-Cookie', [])
        rfc2965 = self._policy.rfc2965
        netscape = self._policy.netscape
        if not rfc2965_hdrs and not ns_hdrs or not ns_hdrs and not rfc2965 or not rfc2965_hdrs and not netscape or not netscape and not rfc2965:
            return []
        else:
            try:
                cookies = self._cookies_from_attrs_set(split_header_words(rfc2965_hdrs), request)
            except Exception:
                _warn_unhandled_exception()
                cookies = []

            if ns_hdrs and netscape:
                try:
                    ns_cookies = self._cookies_from_attrs_set(parse_ns_headers(ns_hdrs), request)
                except Exception:
                    _warn_unhandled_exception()
                    ns_cookies = []

                self._process_rfc2109_cookies(ns_cookies)
                if rfc2965:
                    lookup = {}
                    for cookie in cookies:
                        lookup[cookie.domain, cookie.path, cookie.name] = None

                    def no_matching_rfc2965(ns_cookie, lookup=lookup):
                        key = (ns_cookie.domain, ns_cookie.path, ns_cookie.name)
                        return key not in lookup

                    ns_cookies = filter(no_matching_rfc2965, ns_cookies)
                if ns_cookies:
                    cookies.extend(ns_cookies)
            return cookies

    def set_cookie_if_ok(self, cookie, request):
        self._cookies_lock.acquire()
        try:
            self._policy._now = self._now = int(time.time())
            if self._policy.set_ok(cookie, request):
                self.set_cookie(cookie)
        finally:
            self._cookies_lock.release()

    def set_cookie(self, cookie):
        c = self._cookies
        self._cookies_lock.acquire()
        try:
            if cookie.domain not in c:
                c[cookie.domain] = {}
            c2 = c[cookie.domain]
            if cookie.path not in c2:
                c2[cookie.path] = {}
            c3 = c2[cookie.path]
            c3[cookie.name] = cookie
        finally:
            self._cookies_lock.release()

    def extract_cookies(self, response, request):
        _debug(u'extract_cookies: %s', response.info())
        self._cookies_lock.acquire()
        try:
            self._policy._now = self._now = int(time.time())
            for cookie in self.make_cookies(response, request):
                if self._policy.set_ok(cookie, request):
                    _debug(u' setting cookie: %s', cookie)
                    self.set_cookie(cookie)

        finally:
            self._cookies_lock.release()

    def clear(self, domain=None, path=None, name=None):
        if name is not None:
            if domain is None or path is None:
                raise ValueError(u'domain and path must be given to remove a cookie by name')
            del self._cookies[domain][path][name]
        elif path is not None:
            if domain is None:
                raise ValueError(u'domain must be given to remove cookies by path')
            del self._cookies[domain][path]
        elif domain is not None:
            del self._cookies[domain]
        else:
            self._cookies = {}
        return

    def clear_session_cookies(self):
        self._cookies_lock.acquire()
        try:
            for cookie in self:
                if cookie.discard:
                    self.clear(cookie.domain, cookie.path, cookie.name)

        finally:
            self._cookies_lock.release()

    def clear_expired_cookies(self):
        self._cookies_lock.acquire()
        try:
            now = time.time()
            for cookie in self:
                if cookie.is_expired(now):
                    self.clear(cookie.domain, cookie.path, cookie.name)

        finally:
            self._cookies_lock.release()

    def __iter__(self):
        return deepvalues(self._cookies)

    def __len__(self):
        i = 0
        for cookie in self:
            i = i + 1

        return i

    @as_native_str()
    def __repr__(self):
        r = []
        for cookie in self:
            r.append(repr(cookie))

        return u'<%s[%s]>' % (self.__class__, u', '.join(r))

    def __str__(self):
        r = []
        for cookie in self:
            r.append(str(cookie))

        return u'<%s[%s]>' % (self.__class__, u', '.join(r))


class LoadError(IOError):
    pass


class FileCookieJar(CookieJar):

    def __init__(self, filename=None, delayload=False, policy=None):
        CookieJar.__init__(self, policy)
        if filename is not None:
            try:
                filename + u''
            except:
                raise ValueError(u'filename must be string-like')

        self.filename = filename
        self.delayload = bool(delayload)
        return

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        raise NotImplementedError()

    def load(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None:
                filename = self.filename
            else:
                raise ValueError(MISSING_FILENAME_TEXT)
        f = open(filename)
        try:
            self._really_load(f, filename, ignore_discard, ignore_expires)
        finally:
            f.close()

        return

    def revert(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None:
                filename = self.filename
            else:
                raise ValueError(MISSING_FILENAME_TEXT)
        self._cookies_lock.acquire()
        try:
            old_state = copy.deepcopy(self._cookies)
            self._cookies = {}
            try:
                self.load(filename, ignore_discard, ignore_expires)
            except (LoadError, IOError):
                self._cookies = old_state
                raise

        finally:
            self._cookies_lock.release()

        return


def lwp_cookie_str(cookie):
    h = [(cookie.name, cookie.value), (u'path', cookie.path), (u'domain', cookie.domain)]
    if cookie.port is not None:
        h.append((u'port', cookie.port))
    if cookie.path_specified:
        h.append((u'path_spec', None))
    if cookie.port_specified:
        h.append((u'port_spec', None))
    if cookie.domain_initial_dot:
        h.append((u'domain_dot', None))
    if cookie.secure:
        h.append((u'secure', None))
    if cookie.expires:
        h.append((u'expires', time2isoz(float(cookie.expires))))
    if cookie.discard:
        h.append((u'discard', None))
    if cookie.comment:
        h.append((u'comment', cookie.comment))
    if cookie.comment_url:
        h.append((u'commenturl', cookie.comment_url))
    keys = sorted(cookie._rest.keys())
    for k in keys:
        h.append((k, str(cookie._rest[k])))

    h.append((u'version', str(cookie.version)))
    return join_header_words([h])


class LWPCookieJar(FileCookieJar):

    def as_lwp_str(self, ignore_discard=True, ignore_expires=True):
        now = time.time()
        r = []
        for cookie in self:
            if not ignore_discard and cookie.discard:
                continue
            if not ignore_expires and cookie.is_expired(now):
                continue
            r.append(u'Set-Cookie3: %s' % lwp_cookie_str(cookie))

        return u'\n'.join(r + [u''])

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None:
                filename = self.filename
            else:
                raise ValueError(MISSING_FILENAME_TEXT)
        f = open(filename, u'w')
        try:
            f.write(u'#LWP-Cookies-2.0\n')
            f.write(self.as_lwp_str(ignore_discard, ignore_expires))
        finally:
            f.close()

        return

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        magic = f.readline()
        if not self.magic_re.search(magic):
            msg = u'%r does not look like a Set-Cookie3 (LWP) format file' % filename
            raise LoadError(msg)
        now = time.time()
        header = u'Set-Cookie3:'
        boolean_attrs = (u'port_spec', u'path_spec', u'domain_dot', u'secure', u'discard')
        value_attrs = (u'version', u'port', u'path', u'domain', u'expires', u'comment', u'commenturl')
        try:
            while 1:
                line = f.readline()
                if line == u'':
                    break
                if not line.startswith(header):
                    continue
                line = line[len(header):].strip()
                for data in split_header_words([line]):
                    name, value = data[0]
                    standard = {}
                    rest = {}
                    for k in boolean_attrs:
                        standard[k] = False

                    for k, v in data[1:]:
                        if k is not None:
                            lc = k.lower()
                        else:
                            lc = None
                        if lc in value_attrs or lc in boolean_attrs:
                            k = lc
                        if k in boolean_attrs:
                            if v is None:
                                v = True
                            standard[k] = v
                        if k in value_attrs:
                            standard[k] = v
                        rest[k] = v

                    h = standard.get
                    expires = h(u'expires')
                    discard = h(u'discard')
                    if expires is not None:
                        expires = iso2time(expires)
                    if expires is None:
                        discard = True
                    domain = h(u'domain')
                    domain_specified = domain.startswith(u'.')
                    c = Cookie(h(u'version'), name, value, h(u'port'), h(u'port_spec'), domain, domain_specified, h(u'domain_dot'), h(u'path'), h(u'path_spec'), h(u'secure'), expires, discard, h(u'comment'), h(u'commenturl'), rest)
                    if not ignore_discard and c.discard:
                        continue
                    if not ignore_expires and c.is_expired(now):
                        continue
                    self.set_cookie(c)

        except IOError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError(u'invalid Set-Cookie3 format file %r: %r' % (filename, line))

        return


class MozillaCookieJar(FileCookieJar):
    magic_re = re.compile(u'#( Netscape)? HTTP Cookie File')
    header = u'# Netscape HTTP Cookie File\n# http://www.netscape.com/newsref/std/cookie_spec.html\n# This is a generated file!  Do not edit.\n\n'

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        now = time.time()
        magic = f.readline()
        if not self.magic_re.search(magic):
            f.close()
            raise LoadError(u'%r does not look like a Netscape format cookies file' % filename)
        try:
            while 1:
                line = f.readline()
                if line == u'':
                    break
                if line.endswith(u'\n'):
                    line = line[:-1]
                if line.strip().startswith((u'#', u'$')) or line.strip() == u'':
                    continue
                domain, domain_specified, path, secure, expires, name, value = line.split(u'\t')
                secure = secure == u'TRUE'
                domain_specified = domain_specified == u'TRUE'
                if name == u'':
                    name = value
                    value = None
                initial_dot = domain.startswith(u'.')
                discard = False
                if expires == u'':
                    expires = None
                    discard = True
                c = Cookie(0, name, value, None, False, domain, domain_specified, initial_dot, path, False, secure, expires, discard, None, None, {})
                if not ignore_discard and c.discard:
                    continue
                if not ignore_expires and c.is_expired(now):
                    continue
                self.set_cookie(c)

        except IOError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError(u'invalid Netscape format cookies file %r: %r' % (filename, line))

        return

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None:
                filename = self.filename
            else:
                raise ValueError(MISSING_FILENAME_TEXT)
        f = open(filename, u'w')
        try:
            f.write(self.header)
            now = time.time()
            for cookie in self:
                if not ignore_discard and cookie.discard:
                    continue
                if not ignore_expires and cookie.is_expired(now):
                    continue
                if cookie.secure:
                    secure = u'TRUE'
                else:
                    secure = u'FALSE'
                if cookie.domain.startswith(u'.'):
                    initial_dot = u'TRUE'
                else:
                    initial_dot = u'FALSE'
                if cookie.expires is not None:
                    expires = str(cookie.expires)
                else:
                    expires = u''
                if cookie.value is None:
                    name = u''
                    value = cookie.name
                else:
                    name = cookie.name
                    value = cookie.value
                f.write(u'\t'.join([cookie.domain,
                 initial_dot,
                 cookie.path,
                 secure,
                 expires,
                 name,
                 value]) + u'\n')

        finally:
            f.close()

        return
