# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/http/server.py
from __future__ import absolute_import, division, print_function, unicode_literals
from future import utils
from future.builtins import *
__version__ = u'0.6'
__all__ = [u'HTTPServer', u'BaseHTTPRequestHandler']
from future.backports import html
from future.backports.http import client as http_client
from future.backports.urllib import parse as urllib_parse
from future.backports import socketserver
import io
import mimetypes
import os
import posixpath
import select
import shutil
import socket
import sys
import time
import copy
import argparse
DEFAULT_ERROR_MESSAGE = u'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"\n        "http://www.w3.org/TR/html4/strict.dtd">\n<html>\n    <head>\n        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">\n        <title>Error response</title>\n    </head>\n    <body>\n        <h1>Error response</h1>\n        <p>Error code: %(code)d</p>\n        <p>Message: %(message)s.</p>\n        <p>Error code explanation: %(code)s - %(explain)s.</p>\n    </body>\n</html>\n'
DEFAULT_ERROR_CONTENT_TYPE = u'text/html;charset=utf-8'

def _quote_html(html):
    return html.replace(u'&', u'&amp;').replace(u'<', u'&lt;').replace(u'>', u'&gt;')


class HTTPServer(socketserver.TCPServer):
    allow_reuse_address = 1

    def server_bind(self):
        socketserver.TCPServer.server_bind(self)
        host, port = self.socket.getsockname()[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port


class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):
    sys_version = u'Python/' + sys.version.split()[0]
    server_version = u'BaseHTTP/' + __version__
    error_message_format = DEFAULT_ERROR_MESSAGE
    error_content_type = DEFAULT_ERROR_CONTENT_TYPE
    default_request_version = u'HTTP/0.9'

    def parse_request(self):
        self.command = None
        self.request_version = version = self.default_request_version
        self.close_connection = 1
        requestline = str(self.raw_requestline, u'iso-8859-1')
        requestline = requestline.rstrip(u'\r\n')
        self.requestline = requestline
        words = requestline.split()
        if len(words) == 3:
            command, path, version = words
            if version[:5] != u'HTTP/':
                self.send_error(400, u'Bad request version (%r)' % version)
                return False
            try:
                base_version_number = version.split(u'/', 1)[1]
                version_number = base_version_number.split(u'.')
                if len(version_number) != 2:
                    raise ValueError
                version_number = (int(version_number[0]), int(version_number[1]))
            except (ValueError, IndexError):
                self.send_error(400, u'Bad request version (%r)' % version)
                return False

            if version_number >= (1, 1) and self.protocol_version >= u'HTTP/1.1':
                self.close_connection = 0
            if version_number >= (2, 0):
                self.send_error(505, u'Invalid HTTP Version (%s)' % base_version_number)
                return False
        elif len(words) == 2:
            command, path = words
            self.close_connection = 1
            if command != u'GET':
                self.send_error(400, u'Bad HTTP/0.9 request type (%r)' % command)
                return False
        else:
            if not words:
                return False
            self.send_error(400, u'Bad request syntax (%r)' % requestline)
            return False
        self.command, self.path, self.request_version = command, path, version
        try:
            self.headers = http_client.parse_headers(self.rfile, _class=self.MessageClass)
        except http_client.LineTooLong:
            self.send_error(400, u'Line too long')
            return False

        conntype = self.headers.get(u'Connection', u'')
        if conntype.lower() == u'close':
            self.close_connection = 1
        elif conntype.lower() == u'keep-alive' and self.protocol_version >= u'HTTP/1.1':
            self.close_connection = 0
        expect = self.headers.get(u'Expect', u'')
        if expect.lower() == u'100-continue' and self.protocol_version >= u'HTTP/1.1' and self.request_version >= u'HTTP/1.1':
            if not self.handle_expect_100():
                return False
        return True

    def handle_expect_100(self):
        self.send_response_only(100)
        self.flush_headers()
        return True

    def handle_one_request(self):
        try:
            self.raw_requestline = self.rfile.readline(65537)
            if len(self.raw_requestline) > 65536:
                self.requestline = u''
                self.request_version = u''
                self.command = u''
                self.send_error(414)
                return
            if not self.raw_requestline:
                self.close_connection = 1
                return
            if not self.parse_request():
                return
            mname = u'do_' + self.command
            if not hasattr(self, mname):
                self.send_error(501, u'Unsupported method (%r)' % self.command)
                return
            method = getattr(self, mname)
            method()
            self.wfile.flush()
        except socket.timeout as e:
            self.log_error(u'Request timed out: %r', e)
            self.close_connection = 1
            return

    def handle(self):
        self.close_connection = 1
        self.handle_one_request()
        while not self.close_connection:
            self.handle_one_request()

    def send_error(self, code, message=None):
        try:
            shortmsg, longmsg = self.responses[code]
        except KeyError:
            shortmsg, longmsg = (u'???', u'???')

        if message is None:
            message = shortmsg
        explain = longmsg
        self.log_error(u'code %d, message %s', code, message)
        content = self.error_message_format % {u'code': code,
         u'message': _quote_html(message),
         u'explain': explain}
        self.send_response(code, message)
        self.send_header(u'Content-Type', self.error_content_type)
        self.send_header(u'Connection', u'close')
        self.end_headers()
        if self.command != u'HEAD' and code >= 200 and code not in (204, 304):
            self.wfile.write(content.encode(u'UTF-8', u'replace'))
        return

    def send_response(self, code, message=None):
        self.log_request(code)
        self.send_response_only(code, message)
        self.send_header(u'Server', self.version_string())
        self.send_header(u'Date', self.date_time_string())

    def send_response_only(self, code, message=None):
        if message is None:
            if code in self.responses:
                message = self.responses[code][0]
            else:
                message = u''
        if self.request_version != u'HTTP/0.9':
            if not hasattr(self, u'_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append((u'%s %d %s\r\n' % (self.protocol_version, code, message)).encode(u'latin-1', u'strict'))
        return

    def send_header(self, keyword, value):
        if self.request_version != u'HTTP/0.9':
            if not hasattr(self, u'_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append((u'%s: %s\r\n' % (keyword, value)).encode(u'latin-1', u'strict'))
        if keyword.lower() == u'connection':
            if value.lower() == u'close':
                self.close_connection = 1
            elif value.lower() == u'keep-alive':
                self.close_connection = 0

    def end_headers(self):
        if self.request_version != u'HTTP/0.9':
            self._headers_buffer.append('\r\n')
            self.flush_headers()

    def flush_headers(self):
        if hasattr(self, u'_headers_buffer'):
            self.wfile.write(''.join(self._headers_buffer))
            self._headers_buffer = []

    def log_request(self, code=u'-', size=u'-'):
        self.log_message(u'"%s" %s %s', self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        self.log_message(format, *args)

    def log_message(self, format, *args):
        sys.stderr.write(u'%s - - [%s] %s\n' % (self.address_string(), self.log_date_time_string(), format % args))

    def version_string(self):
        return self.server_version + u' ' + self.sys_version

    def date_time_string(self, timestamp=None):
        if timestamp is None:
            timestamp = time.time()
        year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp)
        s = u'%s, %02d %3s %4d %02d:%02d:%02d GMT' % (self.weekdayname[wd],
         day,
         self.monthname[month],
         year,
         hh,
         mm,
         ss)
        return s

    def log_date_time_string(self):
        now = time.time()
        year, month, day, hh, mm, ss, x, y, z = time.localtime(now)
        s = u'%02d/%3s/%04d %02d:%02d:%02d' % (day,
         self.monthname[month],
         year,
         hh,
         mm,
         ss)
        return s

    weekdayname = [u'Mon',
     u'Tue',
     u'Wed',
     u'Thu',
     u'Fri',
     u'Sat',
     u'Sun']
    monthname = [None,
     u'Jan',
     u'Feb',
     u'Mar',
     u'Apr',
     u'May',
     u'Jun',
     u'Jul',
     u'Aug',
     u'Sep',
     u'Oct',
     u'Nov',
     u'Dec']

    def address_string(self):
        return self.client_address[0]

    protocol_version = u'HTTP/1.0'
    MessageClass = http_client.HTTPMessage
    responses = {100: (u'Continue', u'Request received, please continue'),
     101: (u'Switching Protocols', u'Switching to new protocol; obey Upgrade header'),
     200: (u'OK', u'Request fulfilled, document follows'),
     201: (u'Created', u'Document created, URL follows'),
     202: (u'Accepted', u'Request accepted, processing continues off-line'),
     203: (u'Non-Authoritative Information', u'Request fulfilled from cache'),
     204: (u'No Content', u'Request fulfilled, nothing follows'),
     205: (u'Reset Content', u'Clear input form for further input.'),
     206: (u'Partial Content', u'Partial content follows.'),
     300: (u'Multiple Choices', u'Object has several resources -- see URI list'),
     301: (u'Moved Permanently', u'Object moved permanently -- see URI list'),
     302: (u'Found', u'Object moved temporarily -- see URI list'),
     303: (u'See Other', u'Object moved -- see Method and URL list'),
     304: (u'Not Modified', u'Document has not changed since given time'),
     305: (u'Use Proxy', u'You must use proxy specified in Location to access this resource.'),
     307: (u'Temporary Redirect', u'Object moved temporarily -- see URI list'),
     400: (u'Bad Request', u'Bad request syntax or unsupported method'),
     401: (u'Unauthorized', u'No permission -- see authorization schemes'),
     402: (u'Payment Required', u'No payment -- see charging schemes'),
     403: (u'Forbidden', u'Request forbidden -- authorization will not help'),
     404: (u'Not Found', u'Nothing matches the given URI'),
     405: (u'Method Not Allowed', u'Specified method is invalid for this resource.'),
     406: (u'Not Acceptable', u'URI not available in preferred format.'),
     407: (u'Proxy Authentication Required', u'You must authenticate with this proxy before proceeding.'),
     408: (u'Request Timeout', u'Request timed out; try again later.'),
     409: (u'Conflict', u'Request conflict.'),
     410: (u'Gone', u'URI no longer exists and has been permanently removed.'),
     411: (u'Length Required', u'Client must specify Content-Length.'),
     412: (u'Precondition Failed', u'Precondition in headers is false.'),
     413: (u'Request Entity Too Large', u'Entity is too large.'),
     414: (u'Request-URI Too Long', u'URI is too long.'),
     415: (u'Unsupported Media Type', u'Entity body in unsupported format.'),
     416: (u'Requested Range Not Satisfiable', u'Cannot satisfy request range.'),
     417: (u'Expectation Failed', u'Expect condition could not be satisfied.'),
     428: (u'Precondition Required', u'The origin server requires the request to be conditional.'),
     429: (u'Too Many Requests', u'The user has sent too many requests in a given amount of time ("rate limiting").'),
     431: (u'Request Header Fields Too Large', u'The server is unwilling to process the request because its header fields are too large.'),
     500: (u'Internal Server Error', u'Server got itself in trouble'),
     501: (u'Not Implemented', u'Server does not support this operation'),
     502: (u'Bad Gateway', u'Invalid responses from another server/proxy.'),
     503: (u'Service Unavailable', u'The server cannot process the request due to a high load'),
     504: (u'Gateway Timeout', u'The gateway server did not receive a timely response'),
     505: (u'HTTP Version Not Supported', u'Cannot fulfill request.'),
     511: (u'Network Authentication Required', u'The client needs to authenticate to gain network access.')}


class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    server_version = u'SimpleHTTP/' + __version__

    def do_GET(self):
        f = self.send_head()
        if f:
            self.copyfile(f, self.wfile)
            f.close()

    def do_HEAD(self):
        f = self.send_head()
        if f:
            f.close()

    def send_head(self):
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            if not self.path.endswith(u'/'):
                self.send_response(301)
                self.send_header(u'Location', self.path + u'/')
                self.end_headers()
                return
            for index in (u'index.html', u'index.htm'):
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)

        ctype = self.guess_type(path)
        try:
            f = open(path, u'rb')
        except IOError:
            self.send_error(404, u'File not found')
            return

        self.send_response(200)
        self.send_header(u'Content-type', ctype)
        fs = os.fstat(f.fileno())
        self.send_header(u'Content-Length', str(fs[6]))
        self.send_header(u'Last-Modified', self.date_time_string(fs.st_mtime))
        self.end_headers()
        return f

    def list_directory(self, path):
        try:
            list = os.listdir(path)
        except os.error:
            self.send_error(404, u'No permission to list directory')
            return None

        list.sort(key=lambda a: a.lower())
        r = []
        displaypath = html.escape(urllib_parse.unquote(self.path))
        enc = sys.getfilesystemencoding()
        title = u'Directory listing for %s' % displaypath
        r.append(u'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">')
        r.append(u'<html>\n<head>')
        r.append(u'<meta http-equiv="Content-Type" content="text/html; charset=%s">' % enc)
        r.append(u'<title>%s</title>\n</head>' % title)
        r.append(u'<body>\n<h1>%s</h1>' % title)
        r.append(u'<hr>\n<ul>')
        for name in list:
            fullname = os.path.join(path, name)
            displayname = linkname = name
            if os.path.isdir(fullname):
                displayname = name + u'/'
                linkname = name + u'/'
            if os.path.islink(fullname):
                displayname = name + u'@'
            r.append(u'<li><a href="%s">%s</a></li>' % (urllib_parse.quote(linkname), html.escape(displayname)))

        r.append(u'</ul>\n<hr>\n</body>\n</html>\n')
        encoded = u'\n'.join(r).encode(enc)
        f = io.BytesIO()
        f.write(encoded)
        f.seek(0)
        self.send_response(200)
        self.send_header(u'Content-type', u'text/html; charset=%s' % enc)
        self.send_header(u'Content-Length', str(len(encoded)))
        self.end_headers()
        return f

    def translate_path(self, path):
        path = path.split(u'?', 1)[0]
        path = path.split(u'#', 1)[0]
        path = posixpath.normpath(urllib_parse.unquote(path))
        words = path.split(u'/')
        words = filter(None, words)
        path = os.getcwd()
        for word in words:
            drive, word = os.path.splitdrive(word)
            head, word = os.path.split(word)
            if word in (os.curdir, os.pardir):
                continue
            path = os.path.join(path, word)

        return path

    def copyfile(self, source, outputfile):
        shutil.copyfileobj(source, outputfile)

    def guess_type(self, path):
        base, ext = posixpath.splitext(path)
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        else:
            ext = ext.lower()
            if ext in self.extensions_map:
                return self.extensions_map[ext]
            return self.extensions_map[u'']

    if not mimetypes.inited:
        mimetypes.init()
    extensions_map = mimetypes.types_map.copy()
    extensions_map.update({u'': u'application/octet-stream',
     u'.py': u'text/plain',
     u'.c': u'text/plain',
     u'.h': u'text/plain'})


def _url_collapse_path(path):
    path_parts = path.split(u'/')
    head_parts = []
    for part in path_parts[:-1]:
        if part == u'..':
            head_parts.pop()
        if part and part != u'.':
            head_parts.append(part)

    if path_parts:
        tail_part = path_parts.pop()
        if tail_part:
            if tail_part == u'..':
                head_parts.pop()
                tail_part = u''
            elif tail_part == u'.':
                tail_part = u''
    else:
        tail_part = u''
    splitpath = (u'/' + u'/'.join(head_parts), tail_part)
    collapsed_path = u'/'.join(splitpath)
    return collapsed_path


nobody = None

def nobody_uid():
    global nobody
    if nobody:
        return nobody
    try:
        import pwd
    except ImportError:
        return -1

    try:
        nobody = pwd.getpwnam(u'nobody')[2]
    except KeyError:
        nobody = 1 + max((x[2] for x in pwd.getpwall()))

    return nobody


def executable(path):
    return os.access(path, os.X_OK)


class CGIHTTPRequestHandler(SimpleHTTPRequestHandler):
    have_fork = hasattr(os, u'fork')
    rbufsize = 0

    def do_POST(self):
        if self.is_cgi():
            self.run_cgi()
        else:
            self.send_error(501, u'Can only POST to CGI scripts')

    def send_head(self):
        if self.is_cgi():
            return self.run_cgi()
        else:
            return SimpleHTTPRequestHandler.send_head(self)

    def is_cgi(self):
        collapsed_path = _url_collapse_path(self.path)
        dir_sep = collapsed_path.find(u'/', 1)
        head, tail = collapsed_path[:dir_sep], collapsed_path[dir_sep + 1:]
        if head in self.cgi_directories:
            self.cgi_info = (head, tail)
            return True
        return False

    cgi_directories = [u'/cgi-bin', u'/htbin']

    def is_executable(self, path):
        return executable(path)

    def is_python(self, path):
        head, tail = os.path.splitext(path)
        return tail.lower() in (u'.py', u'.pyw')

    def run_cgi(self):
        path = self.path
        dir, rest = self.cgi_info
        i = path.find(u'/', len(dir) + 1)
        while i >= 0:
            nextdir = path[:i]
            nextrest = path[i + 1:]
            scriptdir = self.translate_path(nextdir)
            if os.path.isdir(scriptdir):
                dir, rest = nextdir, nextrest
                i = path.find(u'/', len(dir) + 1)
            break

        i = rest.rfind(u'?')
        if i >= 0:
            rest, query = rest[:i], rest[i + 1:]
        else:
            query = u''
        i = rest.find(u'/')
        if i >= 0:
            script, rest = rest[:i], rest[i:]
        else:
            script, rest = rest, u''
        scriptname = dir + u'/' + script
        scriptfile = self.translate_path(scriptname)
        if not os.path.exists(scriptfile):
            self.send_error(404, u'No such CGI script (%r)' % scriptname)
            return
        elif not os.path.isfile(scriptfile):
            self.send_error(403, u'CGI script is not a plain file (%r)' % scriptname)
            return
        else:
            ispy = self.is_python(scriptname)
            if self.have_fork or not ispy:
                if not self.is_executable(scriptfile):
                    self.send_error(403, u'CGI script is not executable (%r)' % scriptname)
                    return
            env = copy.deepcopy(os.environ)
            env[u'SERVER_SOFTWARE'] = self.version_string()
            env[u'SERVER_NAME'] = self.server.server_name
            env[u'GATEWAY_INTERFACE'] = u'CGI/1.1'
            env[u'SERVER_PROTOCOL'] = self.protocol_version
            env[u'SERVER_PORT'] = str(self.server.server_port)
            env[u'REQUEST_METHOD'] = self.command
            uqrest = urllib_parse.unquote(rest)
            env[u'PATH_INFO'] = uqrest
            env[u'PATH_TRANSLATED'] = self.translate_path(uqrest)
            env[u'SCRIPT_NAME'] = scriptname
            if query:
                env[u'QUERY_STRING'] = query
            env[u'REMOTE_ADDR'] = self.client_address[0]
            authorization = self.headers.get(u'authorization')
            if authorization:
                authorization = authorization.split()
                if len(authorization) == 2:
                    import base64, binascii
                    env[u'AUTH_TYPE'] = authorization[0]
                    if authorization[0].lower() == u'basic':
                        try:
                            authorization = authorization[1].encode(u'ascii')
                            if utils.PY3:
                                authorization = base64.decodebytes(authorization).decode(u'ascii')
                            else:
                                authorization = base64.decodestring(authorization).decode(u'ascii')
                        except (binascii.Error, UnicodeError):
                            pass
                        else:
                            authorization = authorization.split(u':')
                            if len(authorization) == 2:
                                env[u'REMOTE_USER'] = authorization[0]
            if self.headers.get(u'content-type') is None:
                env[u'CONTENT_TYPE'] = self.headers.get_content_type()
            else:
                env[u'CONTENT_TYPE'] = self.headers[u'content-type']
            length = self.headers.get(u'content-length')
            if length:
                env[u'CONTENT_LENGTH'] = length
            referer = self.headers.get(u'referer')
            if referer:
                env[u'HTTP_REFERER'] = referer
            accept = []
            for line in self.headers.getallmatchingheaders(u'accept'):
                if line[:1] in u'\t\n\r ':
                    accept.append(line.strip())
                accept = accept + line[7:].split(u',')

            env[u'HTTP_ACCEPT'] = u','.join(accept)
            ua = self.headers.get(u'user-agent')
            if ua:
                env[u'HTTP_USER_AGENT'] = ua
            co = filter(None, self.headers.get_all(u'cookie', []))
            cookie_str = u', '.join(co)
            if cookie_str:
                env[u'HTTP_COOKIE'] = cookie_str
            for k in (u'QUERY_STRING', u'REMOTE_HOST', u'CONTENT_LENGTH', u'HTTP_USER_AGENT', u'HTTP_COOKIE', u'HTTP_REFERER'):
                env.setdefault(k, u'')

            self.send_response(200, u'Script output follows')
            self.flush_headers()
            decoded_query = query.replace(u'+', u' ')
            if self.have_fork:
                args = [script]
                if u'=' not in decoded_query:
                    args.append(decoded_query)
                nobody = nobody_uid()
                self.wfile.flush()
                pid = os.fork()
                if pid != 0:
                    pid, sts = os.waitpid(pid, 0)
                    while select.select([self.rfile], [], [], 0)[0]:
                        if not self.rfile.read(1):
                            break

                    if sts:
                        self.log_error(u'CGI script exit status %#x', sts)
                    return
                try:
                    try:
                        os.setuid(nobody)
                    except os.error:
                        pass

                    os.dup2(self.rfile.fileno(), 0)
                    os.dup2(self.wfile.fileno(), 1)
                    os.execve(scriptfile, args, env)
                except:
                    self.server.handle_error(self.request, self.client_address)
                    os._exit(127)

            else:
                import subprocess
                cmdline = [scriptfile]
                if self.is_python(scriptfile):
                    interp = sys.executable
                    if interp.lower().endswith(u'w.exe'):
                        interp = interp[:-5] + interp[-4:]
                    cmdline = [interp, u'-u'] + cmdline
                if u'=' not in query:
                    cmdline.append(query)
                self.log_message(u'command: %s', subprocess.list2cmdline(cmdline))
                try:
                    nbytes = int(length)
                except (TypeError, ValueError):
                    nbytes = 0

                p = subprocess.Popen(cmdline, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
                if self.command.lower() == u'post' and nbytes > 0:
                    data = self.rfile.read(nbytes)
                else:
                    data = None
                while select.select([self.rfile._sock], [], [], 0)[0]:
                    if not self.rfile._sock.recv(1):
                        break

                stdout, stderr = p.communicate(data)
                self.wfile.write(stdout)
                if stderr:
                    self.log_error(u'%s', stderr)
                p.stderr.close()
                p.stdout.close()
                status = p.returncode
                if status:
                    self.log_error(u'CGI script exit status %#x', status)
                else:
                    self.log_message(u'CGI script exited OK')
            return


def test(HandlerClass=BaseHTTPRequestHandler, ServerClass=HTTPServer, protocol=u'HTTP/1.0', port=8000):
    server_address = (u'', port)
    HandlerClass.protocol_version = protocol
    httpd = ServerClass(server_address, HandlerClass)
    sa = httpd.socket.getsockname()
    print(u'Serving HTTP on', sa[0], u'port', sa[1], u'...')
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print(u'\nKeyboard interrupt received, exiting.')
        httpd.server_close()
        sys.exit(0)


if __name__ == u'__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(u'--cgi', action=u'store_true', help=u'Run as CGI Server')
    parser.add_argument(u'port', action=u'store', default=8000, type=int, nargs=u'?', help=u'Specify alternate port [default: 8000]')
    args = parser.parse_args()
    if args.cgi:
        test(HandlerClass=CGIHTTPRequestHandler, port=args.port)
    else:
        test(HandlerClass=SimpleHTTPRequestHandler, port=args.port)
