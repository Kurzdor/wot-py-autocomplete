# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/xmlrpc/client.py
from __future__ import absolute_import, division, print_function, unicode_literals
from future.builtins import bytes, dict, int, range, str
import base64
base64.encodebytes = base64.encodestring
base64.decodebytes = base64.decodestring
import sys
import time
from datetime import datetime
from future.backports.http import client as http_client
from future.backports.urllib import parse as urllib_parse
from future.utils import ensure_new_type
from xml.parsers import expat
import socket
import errno
from io import BytesIO
try:
    import gzip
except ImportError:
    gzip = None

def escape(s):
    s = s.replace(u'&', u'&amp;')
    s = s.replace(u'<', u'&lt;')
    return s.replace(u'>', u'&gt;')


__version__ = sys.version[:3]
MAXINT = 2147483647L
MININT = -2147483648L
PARSE_ERROR = -32700
SERVER_ERROR = -32600
APPLICATION_ERROR = -32500
SYSTEM_ERROR = -32400
TRANSPORT_ERROR = -32300
NOT_WELLFORMED_ERROR = -32700
UNSUPPORTED_ENCODING = -32701
INVALID_ENCODING_CHAR = -32702
INVALID_XMLRPC = -32600
METHOD_NOT_FOUND = -32601
INVALID_METHOD_PARAMS = -32602
INTERNAL_ERROR = -32603

class Error(Exception):

    def __str__(self):
        return repr(self)


class ProtocolError(Error):

    def __init__(self, url, errcode, errmsg, headers):
        Error.__init__(self)
        self.url = url
        self.errcode = errcode
        self.errmsg = errmsg
        self.headers = headers

    def __repr__(self):
        return u'<ProtocolError for %s: %s %s>' % (self.url, self.errcode, self.errmsg)


class ResponseError(Error):
    pass


class Fault(Error):

    def __init__(self, faultCode, faultString, **extra):
        Error.__init__(self)
        self.faultCode = faultCode
        self.faultString = faultString

    def __repr__(self):
        return u'<Fault %s: %r>' % (ensure_new_type(self.faultCode), ensure_new_type(self.faultString))


boolean = Boolean = bool

def _iso8601_format(value):
    return u'%04d%02d%02dT%02d:%02d:%02d' % (value.year,
     value.month,
     value.day,
     value.hour,
     value.minute,
     value.second)


def _strftime(value):
    if isinstance(value, datetime):
        return _iso8601_format(value)
    if not isinstance(value, (tuple, time.struct_time)):
        if value == 0:
            value = time.time()
        value = time.localtime(value)
    return u'%04d%02d%02dT%02d:%02d:%02d' % value[:6]


class DateTime(object):

    def __init__(self, value=0):
        if isinstance(value, str):
            self.value = value
        else:
            self.value = _strftime(value)

    def make_comparable(self, other):
        if isinstance(other, DateTime):
            s = self.value
            o = other.value
        elif isinstance(other, datetime):
            s = self.value
            o = _iso8601_format(other)
        elif isinstance(other, str):
            s = self.value
            o = other
        elif hasattr(other, u'timetuple'):
            s = self.timetuple()
            o = other.timetuple()
        else:
            otype = hasattr(other, u'__class__') and other.__class__.__name__ or type(other)
            raise TypeError(u"Can't compare %s and %s" % (self.__class__.__name__, otype))
        return (s, o)

    def __lt__(self, other):
        s, o = self.make_comparable(other)
        return s < o

    def __le__(self, other):
        s, o = self.make_comparable(other)
        return s <= o

    def __gt__(self, other):
        s, o = self.make_comparable(other)
        return s > o

    def __ge__(self, other):
        s, o = self.make_comparable(other)
        return s >= o

    def __eq__(self, other):
        s, o = self.make_comparable(other)
        return s == o

    def __ne__(self, other):
        s, o = self.make_comparable(other)
        return s != o

    def timetuple(self):
        return time.strptime(self.value, u'%Y%m%dT%H:%M:%S')

    def __str__(self):
        return self.value

    def __repr__(self):
        return u'<DateTime %r at %x>' % (ensure_new_type(self.value), id(self))

    def decode(self, data):
        self.value = str(data).strip()

    def encode(self, out):
        out.write(u'<value><dateTime.iso8601>')
        out.write(self.value)
        out.write(u'</dateTime.iso8601></value>\n')


def _datetime(data):
    value = DateTime()
    value.decode(data)
    return value


def _datetime_type(data):
    return datetime.strptime(data, u'%Y%m%dT%H:%M:%S')


class Binary(object):

    def __init__(self, data=None):
        if data is None:
            data = ''
        else:
            if not isinstance(data, (bytes, bytearray)):
                raise TypeError(u'expected bytes or bytearray, not %s' % data.__class__.__name__)
            data = bytes(data)
        self.data = data
        return

    def __str__(self):
        return str(self.data, u'latin-1')

    def __eq__(self, other):
        if isinstance(other, Binary):
            other = other.data
        return self.data == other

    def __ne__(self, other):
        if isinstance(other, Binary):
            other = other.data
        return self.data != other

    def decode(self, data):
        self.data = base64.decodebytes(data)

    def encode(self, out):
        out.write(u'<value><base64>\n')
        encoded = base64.encodebytes(self.data)
        out.write(encoded.decode(u'ascii'))
        out.write(u'</base64></value>\n')


def _binary(data):
    value = Binary()
    value.decode(data)
    return value


WRAPPERS = (DateTime, Binary)

class ExpatParser(object):

    def __init__(self, target):
        self._parser = parser = expat.ParserCreate(None, None)
        self._target = target
        parser.StartElementHandler = target.start
        parser.EndElementHandler = target.end
        parser.CharacterDataHandler = target.data
        encoding = None
        target.xml(encoding, None)
        return

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        self._parser.Parse(u'', 1)
        del self._target
        del self._parser


class Marshaller(object):

    def __init__(self, encoding=None, allow_none=False):
        self.memo = {}
        self.data = None
        self.encoding = encoding
        self.allow_none = allow_none
        return

    dispatch = {}

    def dumps(self, values):
        out = []
        write = out.append
        dump = self.__dump
        if isinstance(values, Fault):
            write(u'<fault>\n')
            dump({u'faultCode': values.faultCode,
             u'faultString': values.faultString}, write)
            write(u'</fault>\n')
        else:
            write(u'<params>\n')
            for v in values:
                write(u'<param>\n')
                dump(v, write)
                write(u'</param>\n')

            write(u'</params>\n')
        result = u''.join(out)
        return str(result)

    def __dump(self, value, write):
        try:
            f = self.dispatch[type(ensure_new_type(value))]
        except KeyError:
            if not hasattr(value, u'__dict__'):
                raise TypeError(u'cannot marshal %s objects' % type(value))
            for type_ in type(value).__mro__:
                if type_ in self.dispatch.keys():
                    raise TypeError(u'cannot marshal %s objects' % type(value))

            f = self.dispatch[u'_arbitrary_instance']

        f(self, value, write)

    def dump_nil(self, value, write):
        if not self.allow_none:
            raise TypeError(u'cannot marshal None unless allow_none is enabled')
        write(u'<value><nil/></value>')

    dispatch[type(None)] = dump_nil

    def dump_bool(self, value, write):
        write(u'<value><boolean>')
        write(value and u'1' or u'0')
        write(u'</boolean></value>\n')

    dispatch[bool] = dump_bool

    def dump_long(self, value, write):
        if value > MAXINT or value < MININT:
            raise OverflowError(u'long int exceeds XML-RPC limits')
        write(u'<value><int>')
        write(str(int(value)))
        write(u'</int></value>\n')

    dispatch[int] = dump_long
    dump_int = dump_long

    def dump_double(self, value, write):
        write(u'<value><double>')
        write(repr(ensure_new_type(value)))
        write(u'</double></value>\n')

    dispatch[float] = dump_double

    def dump_unicode(self, value, write, escape=escape):
        write(u'<value><string>')
        write(escape(value))
        write(u'</string></value>\n')

    dispatch[str] = dump_unicode

    def dump_bytes(self, value, write):
        write(u'<value><base64>\n')
        encoded = base64.encodebytes(value)
        write(encoded.decode(u'ascii'))
        write(u'</base64></value>\n')

    dispatch[bytes] = dump_bytes
    dispatch[bytearray] = dump_bytes

    def dump_array(self, value, write):
        i = id(value)
        if i in self.memo:
            raise TypeError(u'cannot marshal recursive sequences')
        self.memo[i] = None
        dump = self.__dump
        write(u'<value><array><data>\n')
        for v in value:
            dump(v, write)

        write(u'</data></array></value>\n')
        del self.memo[i]
        return

    dispatch[tuple] = dump_array
    dispatch[list] = dump_array

    def dump_struct(self, value, write, escape=escape):
        i = id(value)
        if i in self.memo:
            raise TypeError(u'cannot marshal recursive dictionaries')
        self.memo[i] = None
        dump = self.__dump
        write(u'<value><struct>\n')
        for k, v in value.items():
            write(u'<member>\n')
            if not isinstance(k, str):
                raise TypeError(u'dictionary key must be string')
            write(u'<name>%s</name>\n' % escape(k))
            dump(v, write)
            write(u'</member>\n')

        write(u'</struct></value>\n')
        del self.memo[i]
        return

    dispatch[dict] = dump_struct

    def dump_datetime(self, value, write):
        write(u'<value><dateTime.iso8601>')
        write(_strftime(value))
        write(u'</dateTime.iso8601></value>\n')

    dispatch[datetime] = dump_datetime

    def dump_instance(self, value, write):
        if value.__class__ in WRAPPERS:
            self.write = write
            value.encode(self)
            del self.write
        else:
            self.dump_struct(value.__dict__, write)

    dispatch[DateTime] = dump_instance
    dispatch[Binary] = dump_instance
    dispatch[u'_arbitrary_instance'] = dump_instance


class Unmarshaller(object):

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._type = None
        self._stack = []
        self._marks = []
        self._data = []
        self._methodname = None
        self._encoding = u'utf-8'
        self.append = self._stack.append
        self._use_datetime = use_builtin_types or use_datetime
        self._use_bytes = use_builtin_types
        return

    def close(self):
        if self._type is None or self._marks:
            raise ResponseError()
        if self._type == u'fault':
            raise Fault(**self._stack[0])
        return tuple(self._stack)

    def getmethodname(self):
        return self._methodname

    def xml(self, encoding, standalone):
        self._encoding = encoding

    def start(self, tag, attrs):
        if tag == u'array' or tag == u'struct':
            self._marks.append(len(self._stack))
        self._data = []
        self._value = tag == u'value'

    def data(self, text):
        self._data.append(text)

    def end(self, tag):
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass
        else:
            return f(self, u''.join(self._data))

    def end_dispatch(self, tag, data):
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass
        else:
            return f(self, data)

    dispatch = {}

    def end_nil(self, data):
        self.append(None)
        self._value = 0
        return

    dispatch[u'nil'] = end_nil

    def end_boolean(self, data):
        if data == u'0':
            self.append(False)
        elif data == u'1':
            self.append(True)
        else:
            raise TypeError(u'bad boolean value')
        self._value = 0

    dispatch[u'boolean'] = end_boolean

    def end_int(self, data):
        self.append(int(data))
        self._value = 0

    dispatch[u'i4'] = end_int
    dispatch[u'i8'] = end_int
    dispatch[u'int'] = end_int

    def end_double(self, data):
        self.append(float(data))
        self._value = 0

    dispatch[u'double'] = end_double

    def end_string(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self.append(data)
        self._value = 0

    dispatch[u'string'] = end_string
    dispatch[u'name'] = end_string

    def end_array(self, data):
        mark = self._marks.pop()
        self._stack[mark:] = [self._stack[mark:]]
        self._value = 0

    dispatch[u'array'] = end_array

    def end_struct(self, data):
        mark = self._marks.pop()
        dict = {}
        items = self._stack[mark:]
        for i in range(0, len(items), 2):
            dict[items[i]] = items[i + 1]

        self._stack[mark:] = [dict]
        self._value = 0

    dispatch[u'struct'] = end_struct

    def end_base64(self, data):
        value = Binary()
        value.decode(data.encode(u'ascii'))
        if self._use_bytes:
            value = value.data
        self.append(value)
        self._value = 0

    dispatch[u'base64'] = end_base64

    def end_dateTime(self, data):
        value = DateTime()
        value.decode(data)
        if self._use_datetime:
            value = _datetime_type(data)
        self.append(value)

    dispatch[u'dateTime.iso8601'] = end_dateTime

    def end_value(self, data):
        if self._value:
            self.end_string(data)

    dispatch[u'value'] = end_value

    def end_params(self, data):
        self._type = u'params'

    dispatch[u'params'] = end_params

    def end_fault(self, data):
        self._type = u'fault'

    dispatch[u'fault'] = end_fault

    def end_methodName(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self._methodname = data
        self._type = u'methodName'

    dispatch[u'methodName'] = end_methodName


class _MultiCallMethod(object):

    def __init__(self, call_list, name):
        self.__call_list = call_list
        self.__name = name

    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, u'%s.%s' % (self.__name, name))

    def __call__(self, *args):
        self.__call_list.append((self.__name, args))


class MultiCallIterator(object):

    def __init__(self, results):
        self.results = results

    def __getitem__(self, i):
        item = self.results[i]
        if isinstance(type(item), dict):
            raise Fault(item[u'faultCode'], item[u'faultString'])
        else:
            if type(item) == type([]):
                return item[0]
            raise ValueError(u'unexpected type in multicall result')


class MultiCall(object):

    def __init__(self, server):
        self.__server = server
        self.__call_list = []

    def __repr__(self):
        return u'<MultiCall at %x>' % id(self)

    __str__ = __repr__

    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, name)

    def __call__(self):
        marshalled_list = []
        for name, args in self.__call_list:
            marshalled_list.append({u'methodName': name,
             u'params': args})

        return MultiCallIterator(self.__server.system.multicall(marshalled_list))


FastMarshaller = FastParser = FastUnmarshaller = None

def getparser(use_datetime=False, use_builtin_types=False):
    if FastParser and FastUnmarshaller:
        if use_builtin_types:
            mkdatetime = _datetime_type
            mkbytes = base64.decodebytes
        elif use_datetime:
            mkdatetime = _datetime_type
            mkbytes = _binary
        else:
            mkdatetime = _datetime
            mkbytes = _binary
        target = FastUnmarshaller(True, False, mkbytes, mkdatetime, Fault)
        parser = FastParser(target)
    else:
        target = Unmarshaller(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        if FastParser:
            parser = FastParser(target)
        else:
            parser = ExpatParser(target)
    return (parser, target)


def dumps(params, methodname=None, methodresponse=None, encoding=None, allow_none=False):
    if isinstance(params, Fault):
        methodresponse = 1
    elif methodresponse and isinstance(params, tuple):
        pass
    if not encoding:
        encoding = u'utf-8'
    if FastMarshaller:
        m = FastMarshaller(encoding)
    else:
        m = Marshaller(encoding, allow_none)
    data = m.dumps(params)
    if encoding != u'utf-8':
        xmlheader = u"<?xml version='1.0' encoding='%s'?>\n" % str(encoding)
    else:
        xmlheader = u"<?xml version='1.0'?>\n"
    if methodname:
        if not isinstance(methodname, str):
            methodname = methodname.encode(encoding)
        data = (xmlheader,
         u'<methodCall>\n<methodName>',
         methodname,
         u'</methodName>\n',
         data,
         u'</methodCall>\n')
    elif methodresponse:
        data = (xmlheader,
         u'<methodResponse>\n',
         data,
         u'</methodResponse>\n')
    else:
        return data
    return str(u'').join(data)


def loads(data, use_datetime=False, use_builtin_types=False):
    p, u = getparser(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
    p.feed(data)
    p.close()
    return (u.close(), u.getmethodname())


def gzip_encode(data):
    if not gzip:
        raise NotImplementedError
    f = BytesIO()
    gzf = gzip.GzipFile(mode=u'wb', fileobj=f, compresslevel=1)
    gzf.write(data)
    gzf.close()
    encoded = f.getvalue()
    f.close()
    return encoded


def gzip_decode(data):
    if not gzip:
        raise NotImplementedError
    f = BytesIO(data)
    gzf = gzip.GzipFile(mode=u'rb', fileobj=f)
    try:
        decoded = gzf.read()
    except IOError:
        raise ValueError(u'invalid data')

    f.close()
    gzf.close()
    return decoded


class GzipDecodedResponse(gzip.GzipFile if gzip else object):

    def __init__(self, response):
        if not gzip:
            raise NotImplementedError
        self.io = BytesIO(response.read())
        gzip.GzipFile.__init__(self, mode=u'rb', fileobj=self.io)

    def close(self):
        gzip.GzipFile.close(self)
        self.io.close()


class _Method(object):

    def __init__(self, send, name):
        self.__send = send
        self.__name = name

    def __getattr__(self, name):
        return _Method(self.__send, u'%s.%s' % (self.__name, name))

    def __call__(self, *args):
        return self.__send(self.__name, args)


class Transport(object):
    user_agent = u'Python-xmlrpc/%s' % __version__
    accept_gzip_encoding = True
    encode_threshold = None

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._use_datetime = use_datetime
        self._use_builtin_types = use_builtin_types
        self._connection = (None, None)
        self._extra_headers = []
        return None

    def request(self, host, handler, request_body, verbose=False):
        for i in (0, 1):
            try:
                return self.single_request(host, handler, request_body, verbose)
            except socket.error as e:
                if i or e.errno not in (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE):
                    raise
            except http_client.BadStatusLine:
                if i:
                    raise

    def single_request(self, host, handler, request_body, verbose=False):
        try:
            http_conn = self.send_request(host, handler, request_body, verbose)
            resp = http_conn.getresponse()
            if resp.status == 200:
                self.verbose = verbose
                return self.parse_response(resp)
        except Fault:
            raise
        except Exception:
            self.close()
            raise

        if resp.getheader(u'content-length', u''):
            resp.read()
        raise ProtocolError(host + handler, resp.status, resp.reason, dict(resp.getheaders()))

    def getparser(self):
        return getparser(use_datetime=self._use_datetime, use_builtin_types=self._use_builtin_types)

    def get_host_info(self, host):
        x509 = {}
        if isinstance(host, tuple):
            host, x509 = host
        auth, host = urllib_parse.splituser(host)
        if auth:
            auth = urllib_parse.unquote_to_bytes(auth)
            auth = base64.encodebytes(auth).decode(u'utf-8')
            auth = u''.join(auth.split())
            extra_headers = [(u'Authorization', u'Basic ' + auth)]
        else:
            extra_headers = []
        return (host, extra_headers, x509)

    def make_connection(self, host):
        if self._connection and host == self._connection[0]:
            return self._connection[1]
        chost, self._extra_headers, x509 = self.get_host_info(host)
        self._connection = (host, http_client.HTTPConnection(chost))
        return self._connection[1]

    def close(self):
        if self._connection[1]:
            self._connection[1].close()
            self._connection = (None, None)
        return None

    def send_request(self, host, handler, request_body, debug):
        connection = self.make_connection(host)
        headers = self._extra_headers[:]
        if debug:
            connection.set_debuglevel(1)
        if self.accept_gzip_encoding and gzip:
            connection.putrequest(u'POST', handler, skip_accept_encoding=True)
            headers.append((u'Accept-Encoding', u'gzip'))
        else:
            connection.putrequest(u'POST', handler)
        headers.append((u'Content-Type', u'text/xml'))
        headers.append((u'User-Agent', self.user_agent))
        self.send_headers(connection, headers)
        self.send_content(connection, request_body)
        return connection

    def send_headers(self, connection, headers):
        for key, val in headers:
            connection.putheader(key, val)

    def send_content(self, connection, request_body):
        if self.encode_threshold is not None and self.encode_threshold < len(request_body) and gzip:
            connection.putheader(u'Content-Encoding', u'gzip')
            request_body = gzip_encode(request_body)
        connection.putheader(u'Content-Length', str(len(request_body)))
        connection.endheaders(request_body)
        return

    def parse_response(self, response):
        if hasattr(response, u'getheader'):
            if response.getheader(u'Content-Encoding', u'') == u'gzip':
                stream = GzipDecodedResponse(response)
            else:
                stream = response
        else:
            stream = response
        p, u = self.getparser()
        while 1:
            data = stream.read(1024)
            if not data:
                break
            if self.verbose:
                print(u'body:', repr(data))
            p.feed(data)

        if stream is not response:
            stream.close()
        p.close()
        return u.close()


class SafeTransport(Transport):

    def make_connection(self, host):
        if self._connection and host == self._connection[0]:
            return self._connection[1]
        else:
            if not hasattr(http_client, u'HTTPSConnection'):
                raise NotImplementedError(u"your version of http.client doesn't support HTTPS")
            chost, self._extra_headers, x509 = self.get_host_info(host)
            self._connection = (host, http_client.HTTPSConnection(chost, None, **(x509 or {})))
            return self._connection[1]


class ServerProxy(object):

    def __init__(self, uri, transport=None, encoding=None, verbose=False, allow_none=False, use_datetime=False, use_builtin_types=False):
        type, uri = urllib_parse.splittype(uri)
        if type not in (u'http', u'https'):
            raise IOError(u'unsupported XML-RPC protocol')
        self.__host, self.__handler = urllib_parse.splithost(uri)
        if not self.__handler:
            self.__handler = u'/RPC2'
        if transport is None:
            if type == u'https':
                handler = SafeTransport
            else:
                handler = Transport
            transport = handler(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        self.__transport = transport
        self.__encoding = encoding or u'utf-8'
        self.__verbose = verbose
        self.__allow_none = allow_none
        return

    def __close(self):
        self.__transport.close()

    def __request(self, methodname, params):
        request = dumps(params, methodname, encoding=self.__encoding, allow_none=self.__allow_none).encode(self.__encoding)
        response = self.__transport.request(self.__host, self.__handler, request, verbose=self.__verbose)
        if len(response) == 1:
            response = response[0]
        return response

    def __repr__(self):
        return u'<ServerProxy for %s%s>' % (self.__host, self.__handler)

    __str__ = __repr__

    def __getattr__(self, name):
        return _Method(self.__request, name)

    def __call__(self, attr):
        if attr == u'close':
            return self.__close
        if attr == u'transport':
            return self.__transport
        raise AttributeError(u'Attribute %r not found' % (attr,))


Server = ServerProxy
if __name__ == u'__main__':
    server = ServerProxy(u'http://localhost:8000')
    try:
        print(server.currentTime.getCurrentTime())
    except Error as v:
        print(u'ERROR', v)

    multi = MultiCall(server)
    multi.getData()
    multi.pow(2, 9)
    multi.add(1, 2)
    try:
        for response in multi():
            print(response)

    except Error as v:
        print(u'ERROR', v)
