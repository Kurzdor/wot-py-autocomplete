# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/test/support.py
from __future__ import absolute_import, division, print_function, unicode_literals
from future import utils
from future.builtins import str, range, open, int, map, list
import contextlib
import errno
import functools
import gc
import socket
import sys
import os
import platform
import shutil
import warnings
import unittest
if not hasattr(unittest, u'skip'):
    import unittest2 as unittest
import importlib
import re
import subprocess
import imp
import time
try:
    import sysconfig
except ImportError:
    from distutils import sysconfig

import fnmatch
import logging.handlers
import struct
import tempfile
try:
    if utils.PY3:
        import _thread, threading
    else:
        import thread as _thread, threading
except ImportError:
    _thread = None
    threading = None

try:
    import multiprocessing.process
except ImportError:
    multiprocessing = None

try:
    import zlib
except ImportError:
    zlib = None

try:
    import gzip
except ImportError:
    gzip = None

try:
    import bz2
except ImportError:
    bz2 = None

try:
    import lzma
except ImportError:
    lzma = None

__all__ = [u'Error',
 u'TestFailed',
 u'ResourceDenied',
 u'import_module',
 u'verbose',
 u'use_resources',
 u'max_memuse',
 u'record_original_stdout',
 u'get_original_stdout',
 u'unload',
 u'unlink',
 u'rmtree',
 u'forget',
 u'is_resource_enabled',
 u'requires',
 u'requires_freebsd_version',
 u'requires_linux_version',
 u'requires_mac_ver',
 u'find_unused_port',
 u'bind_port',
 u'IPV6_ENABLED',
 u'is_jython',
 u'TESTFN',
 u'HOST',
 u'SAVEDCWD',
 u'temp_cwd',
 u'findfile',
 u'create_empty_file',
 u'sortdict',
 u'check_syntax_error',
 u'open_urlresource',
 u'check_warnings',
 u'CleanImport',
 u'EnvironmentVarGuard',
 u'TransientResource',
 u'captured_stdout',
 u'captured_stdin',
 u'captured_stderr',
 u'time_out',
 u'socket_peer_reset',
 u'ioerror_peer_reset',
 u'run_with_locale',
 u'temp_umask',
 u'transient_internet',
 u'set_memlimit',
 u'bigmemtest',
 u'bigaddrspacetest',
 u'BasicTestRunner',
 u'run_unittest',
 u'run_doctest',
 u'threading_setup',
 u'threading_cleanup',
 u'reap_children',
 u'cpython_only',
 u'check_impl_detail',
 u'get_attribute',
 u'swap_item',
 u'swap_attr',
 u'requires_IEEE_754',
 u'TestHandler',
 u'Matcher',
 u'can_symlink',
 u'skip_unless_symlink',
 u'skip_unless_xattr',
 u'import_fresh_module',
 u'requires_zlib',
 u'PIPE_MAX_SIZE',
 u'failfast',
 u'anticipate_failure',
 u'run_with_tz',
 u'requires_gzip',
 u'requires_bz2',
 u'requires_lzma',
 u'suppress_crash_popup']

class Error(Exception):
    pass


class TestFailed(Error):
    pass


class ResourceDenied(unittest.SkipTest):
    pass


@contextlib.contextmanager
def _ignore_deprecated_imports(ignore=True):
    if ignore:
        with warnings.catch_warnings():
            warnings.filterwarnings(u'ignore', u'.+ (module|package)', DeprecationWarning)
            yield
    else:
        yield


def import_module(name, deprecated=False):
    with _ignore_deprecated_imports(deprecated):
        try:
            return importlib.import_module(name)
        except ImportError as msg:
            raise unittest.SkipTest(str(msg))


def _save_and_remove_module(name, orig_modules):
    if name not in sys.modules:
        __import__(name)
        del sys.modules[name]
    for modname in list(sys.modules):
        if modname == name or modname.startswith(name + u'.'):
            orig_modules[modname] = sys.modules[modname]
            del sys.modules[modname]


def _save_and_block_module(name, orig_modules):
    saved = True
    try:
        orig_modules[name] = sys.modules[name]
    except KeyError:
        saved = False

    sys.modules[name] = None
    return saved


def anticipate_failure(condition):
    return unittest.expectedFailure if condition else (lambda f: f)


def import_fresh_module(name, fresh=(), blocked=(), deprecated=False):
    with _ignore_deprecated_imports(deprecated):
        orig_modules = {}
        names_to_remove = []
        _save_and_remove_module(name, orig_modules)
        try:
            try:
                for fresh_name in fresh:
                    _save_and_remove_module(fresh_name, orig_modules)

                for blocked_name in blocked:
                    if not _save_and_block_module(blocked_name, orig_modules):
                        names_to_remove.append(blocked_name)

                fresh_module = importlib.import_module(name)
            except ImportError:
                fresh_module = None

        finally:
            for orig_name, module in orig_modules.items():
                sys.modules[orig_name] = module

            for name_to_remove in names_to_remove:
                del sys.modules[name_to_remove]

        return fresh_module
    return


def get_attribute(obj, name):
    try:
        attribute = getattr(obj, name)
    except AttributeError:
        raise unittest.SkipTest(u'object %r has no attribute %r' % (obj, name))
    else:
        return attribute


verbose = 1
use_resources = None
max_memuse = 0
real_max_memuse = 0
failfast = False
match_tests = None
_original_stdout = None

def record_original_stdout(stdout):
    global _original_stdout
    _original_stdout = stdout


def get_original_stdout():
    return _original_stdout or sys.stdout


def unload(name):
    try:
        del sys.modules[name]
    except KeyError:
        pass


if sys.platform.startswith(u'win'):

    def _waitfor(func, pathname, waitall=False):
        func(pathname)
        if waitall:
            dirname = pathname
        else:
            dirname, name = os.path.split(pathname)
            dirname = dirname or u'.'
        timeout = 0.001
        while timeout < 1.0:
            L = os.listdir(dirname)
            if not (L if waitall else name in L):
                return
            time.sleep(timeout)
            timeout *= 2

        warnings.warn(u'tests may fail, delete still pending for ' + pathname, RuntimeWarning, stacklevel=4)


    def _unlink(filename):
        _waitfor(os.unlink, filename)


    def _rmdir(dirname):
        _waitfor(os.rmdir, dirname)


    def _rmtree(path):

        def _rmtree_inner(path):
            for name in os.listdir(path):
                fullname = os.path.join(path, name)
                if os.path.isdir(fullname):
                    _waitfor(_rmtree_inner, fullname, waitall=True)
                    os.rmdir(fullname)
                os.unlink(fullname)

        _waitfor(_rmtree_inner, path, waitall=True)
        _waitfor(os.rmdir, path)


else:
    _unlink = os.unlink
    _rmdir = os.rmdir
    _rmtree = shutil.rmtree

def unlink(filename):
    try:
        _unlink(filename)
    except OSError as error:
        if error.errno not in (errno.ENOENT, errno.ENOTDIR):
            raise


def rmdir(dirname):
    try:
        _rmdir(dirname)
    except OSError as error:
        if error.errno != errno.ENOENT:
            raise


def rmtree(path):
    try:
        _rmtree(path)
    except OSError as error:
        if error.errno != errno.ENOENT:
            raise


def make_legacy_pyc(source):
    pyc_file = imp.cache_from_source(source)
    up_one = os.path.dirname(os.path.abspath(source))
    legacy_pyc = os.path.join(up_one, source + (u'c' if __debug__ else u'o'))
    os.rename(pyc_file, legacy_pyc)
    return legacy_pyc


def forget(modname):
    unload(modname)
    for dirname in sys.path:
        source = os.path.join(dirname, modname + u'.py')
        unlink(source + u'c')
        unlink(source + u'o')
        unlink(imp.cache_from_source(source, debug_override=True))
        unlink(imp.cache_from_source(source, debug_override=False))


if sys.platform.startswith(u'win'):
    import ctypes
    import ctypes.wintypes

    def _is_gui_available():
        UOI_FLAGS = 1
        WSF_VISIBLE = 1

        class USEROBJECTFLAGS(ctypes.Structure):
            _fields_ = [(u'fInherit', ctypes.wintypes.BOOL), (u'fReserved', ctypes.wintypes.BOOL), (u'dwFlags', ctypes.wintypes.DWORD)]

        dll = ctypes.windll.user32
        h = dll.GetProcessWindowStation()
        if not h:
            raise ctypes.WinError()
        uof = USEROBJECTFLAGS()
        needed = ctypes.wintypes.DWORD()
        res = dll.GetUserObjectInformationW(h, UOI_FLAGS, ctypes.byref(uof), ctypes.sizeof(uof), ctypes.byref(needed))
        if not res:
            raise ctypes.WinError()
        return bool(uof.dwFlags & WSF_VISIBLE)


else:

    def _is_gui_available():
        return True


def is_resource_enabled(resource):
    return use_resources is not None and resource in use_resources


def requires(resource, msg=None):
    if resource == u'gui' and not _is_gui_available():
        raise unittest.SkipTest(u"Cannot use the 'gui' resource")
    if sys._getframe(1).f_globals.get(u'__name__') == u'__main__':
        return
    else:
        if not is_resource_enabled(resource):
            if msg is None:
                msg = u'Use of the %r resource not enabled' % resource
            raise ResourceDenied(msg)
        return


def _requires_unix_version(sysname, min_version):

    def decorator(func):

        @functools.wraps(func)
        def wrapper(*args, **kw):
            if platform.system() == sysname:
                version_txt = platform.release().split(u'-', 1)[0]
                try:
                    version = tuple(map(int, version_txt.split(u'.')))
                except ValueError:
                    pass
                else:
                    if version < min_version:
                        min_version_txt = u'.'.join(map(str, min_version))
                        raise unittest.SkipTest(u'%s version %s or higher required, not %s' % (sysname, min_version_txt, version_txt))
            return func(*args, **kw)

        wrapper.min_version = min_version
        return wrapper

    return decorator


def requires_freebsd_version(*min_version):
    return _requires_unix_version(u'FreeBSD', min_version)


def requires_linux_version(*min_version):
    return _requires_unix_version(u'Linux', min_version)


def requires_mac_ver(*min_version):

    def decorator(func):

        @functools.wraps(func)
        def wrapper(*args, **kw):
            if sys.platform == u'darwin':
                version_txt = platform.mac_ver()[0]
                try:
                    version = tuple(map(int, version_txt.split(u'.')))
                except ValueError:
                    pass
                else:
                    if version < min_version:
                        min_version_txt = u'.'.join(map(str, min_version))
                        raise unittest.SkipTest(u'Mac OS X %s or higher required, not %s' % (min_version_txt, version_txt))
            return func(*args, **kw)

        wrapper.min_version = min_version
        return wrapper

    return decorator


HOST = u'127.0.0.1'
HOSTv6 = u'::1'

def find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
    tempsock = socket.socket(family, socktype)
    port = bind_port(tempsock)
    tempsock.close()
    del tempsock
    return port


def bind_port(sock, host=HOST):
    if sock.family == socket.AF_INET and sock.type == socket.SOCK_STREAM:
        if hasattr(socket, u'SO_REUSEADDR'):
            if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) == 1:
                raise TestFailed(u'tests should never set the SO_REUSEADDR socket option on TCP/IP sockets!')
        if hasattr(socket, u'SO_REUSEPORT'):
            try:
                if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:
                    raise TestFailed(u'tests should never set the SO_REUSEPORT socket option on TCP/IP sockets!')
            except socket.error:
                pass

        if hasattr(socket, u'SO_EXCLUSIVEADDRUSE'):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)
    sock.bind((host, 0))
    port = sock.getsockname()[1]
    return port


def _is_ipv6_enabled():
    if socket.has_ipv6:
        sock = None
        try:
            try:
                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
                sock.bind((u'::1', 0))
                return True
            except (socket.error, socket.gaierror):
                pass

        finally:
            if sock:
                sock.close()

    return False


IPV6_ENABLED = _is_ipv6_enabled()
PIPE_MAX_SIZE = 4194305
SOCK_MAX_SIZE = 16777217
requires_zlib = unittest.skipUnless(zlib, u'requires zlib')
requires_bz2 = unittest.skipUnless(bz2, u'requires bz2')
requires_lzma = unittest.skipUnless(lzma, u'requires lzma')
is_jython = sys.platform.startswith(u'java')
if os.name == u'java':
    TESTFN = u'$test'
else:
    TESTFN = u'@test'
TESTFN = u'{0}_{1}_tmp'.format(TESTFN, os.getpid())
SAVEDCWD = os.getcwd()

@contextlib.contextmanager
def temp_cwd(name=u'tempcwd', quiet=False, path=None):
    saved_dir = os.getcwd()
    is_temporary = False
    if path is None:
        path = name
        try:
            os.mkdir(name)
            is_temporary = True
        except OSError:
            if not quiet:
                raise
            warnings.warn(u'tests may fail, unable to create temp CWD ' + name, RuntimeWarning, stacklevel=3)

    try:
        os.chdir(path)
    except OSError:
        if not quiet:
            raise
        warnings.warn(u'tests may fail, unable to change the CWD to ' + path, RuntimeWarning, stacklevel=3)

    try:
        yield os.getcwd()
    finally:
        os.chdir(saved_dir)
        if is_temporary:
            rmtree(name)

    return


if hasattr(os, u'umask'):

    @contextlib.contextmanager
    def temp_umask(umask):
        oldmask = os.umask(umask)
        try:
            yield
        finally:
            os.umask(oldmask)


def findfile(file, here=__file__, subdir=None):
    if os.path.isabs(file):
        return file
    else:
        if subdir is not None:
            file = os.path.join(subdir, file)
        path = sys.path
        path = [os.path.dirname(here)] + path
        for dn in path:
            fn = os.path.join(dn, file)
            if os.path.exists(fn):
                return fn

        return file


def create_empty_file(filename):
    fd = os.open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)
    os.close(fd)


def sortdict(dict):
    items = sorted(dict.items())
    reprpairs = [ u'%r: %r' % pair for pair in items ]
    withcommas = u', '.join(reprpairs)
    return u'{%s}' % withcommas


def make_bad_fd():
    file = open(TESTFN, u'wb')
    try:
        return file.fileno()
    finally:
        file.close()
        unlink(TESTFN)


def check_syntax_error(testcase, statement):
    testcase.assertRaises(SyntaxError, compile, statement, u'<test string>', u'exec')


def open_urlresource(url, *args, **kw):
    from future.backports.urllib import request as urllib_request, parse as urllib_parse
    check = kw.pop(u'check', None)
    filename = urllib_parse.urlparse(url)[2].split(u'/')[-1]
    fn = os.path.join(os.path.dirname(__file__), u'data', filename)

    def check_valid_file(fn):
        f = open(fn, *args, **kw)
        if check is None:
            return f
        elif check(f):
            f.seek(0)
            return f
        else:
            f.close()
            return

    if os.path.exists(fn):
        f = check_valid_file(fn)
        if f is not None:
            return f
        unlink(fn)
    requires(u'urlfetch')
    print(u'\tfetching %s ...' % url, file=get_original_stdout())
    f = urllib_request.urlopen(url, timeout=15)
    try:
        with open(fn, u'wb') as out:
            s = f.read()
            while s:
                out.write(s)
                s = f.read()

    finally:
        f.close()

    f = check_valid_file(fn)
    if f is not None:
        return f
    else:
        raise TestFailed(u'invalid resource %r' % fn)
        return


class WarningsRecorder(object):

    def __init__(self, warnings_list):
        self._warnings = warnings_list
        self._last = 0

    def __getattr__(self, attr):
        if len(self._warnings) > self._last:
            return getattr(self._warnings[-1], attr)
        elif attr in warnings.WarningMessage._WARNING_DETAILS:
            return None
        else:
            raise AttributeError(u'%r has no attribute %r' % (self, attr))
            return None

    @property
    def warnings(self):
        return self._warnings[self._last:]

    def reset(self):
        self._last = len(self._warnings)


def _filterwarnings(filters, quiet=False):
    frame = sys._getframe(2)
    registry = frame.f_globals.get(u'__warningregistry__')
    if registry:
        if utils.PY3:
            registry.clear()
        else:
            for i in range(len(registry)):
                registry.pop()

    with warnings.catch_warnings(record=True) as w:
        sys.modules[u'warnings'].simplefilter(u'always')
        yield WarningsRecorder(w)
    reraise = list(w)
    missing = []
    for msg, cat in filters:
        seen = False
        for w in reraise[:]:
            warning = w.message
            if re.match(msg, str(warning), re.I) and issubclass(warning.__class__, cat):
                seen = True
                reraise.remove(w)

        if not seen and not quiet:
            missing.append((msg, cat.__name__))

    if reraise:
        raise AssertionError(u'unhandled warning %s' % reraise[0])
    if missing:
        raise AssertionError(u'filter (%r, %s) did not catch any warning' % missing[0])


@contextlib.contextmanager
def check_warnings(*filters, **kwargs):
    quiet = kwargs.get(u'quiet')
    if not filters:
        filters = ((u'', Warning),)
        if quiet is None:
            quiet = True
    return _filterwarnings(filters, quiet)


class CleanImport(object):

    def __init__(self, *module_names):
        self.original_modules = sys.modules.copy()
        for module_name in module_names:
            if module_name in sys.modules:
                module = sys.modules[module_name]
                if module.__name__ != module_name:
                    del sys.modules[module.__name__]
                del sys.modules[module_name]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.modules.update(self.original_modules)


if utils.PY3:
    import collections.abc
    mybase = collections.abc.MutableMapping
else:
    import UserDict
    mybase = UserDict.DictMixin

class EnvironmentVarGuard(mybase):

    def __init__(self):
        self._environ = os.environ
        self._changed = {}

    def __getitem__(self, envvar):
        return self._environ[envvar]

    def __setitem__(self, envvar, value):
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        self._environ[envvar] = value

    def __delitem__(self, envvar):
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        if envvar in self._environ:
            del self._environ[envvar]

    def keys(self):
        return self._environ.keys()

    def __iter__(self):
        return iter(self._environ)

    def __len__(self):
        return len(self._environ)

    def set(self, envvar, value):
        self[envvar] = value

    def unset(self, envvar):
        del self[envvar]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        for k, v in self._changed.items():
            if v is None:
                if k in self._environ:
                    del self._environ[k]
            self._environ[k] = v

        os.environ = self._environ
        return


class DirsOnSysPath(object):

    def __init__(self, *paths):
        self.original_value = sys.path[:]
        self.original_object = sys.path
        sys.path.extend(paths)

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.path = self.original_object
        sys.path[:] = self.original_value


class TransientResource(object):

    def __init__(self, exc, **kwargs):
        self.exc = exc
        self.attrs = kwargs

    def __enter__(self):
        return self

    def __exit__(self, type_=None, value=None, traceback=None):
        if type_ is not None and issubclass(self.exc, type_):
            for attr, attr_value in self.attrs.items():
                if not hasattr(value, attr):
                    break
                if getattr(value, attr) != attr_value:
                    break
            else:
                raise ResourceDenied(u'an optional resource is not available')

        return


time_out = TransientResource(IOError, errno=errno.ETIMEDOUT)
socket_peer_reset = TransientResource(socket.error, errno=errno.ECONNRESET)
ioerror_peer_reset = TransientResource(IOError, errno=errno.ECONNRESET)

@contextlib.contextmanager
def transient_internet(resource_name, timeout=30.0, errnos=()):
    default_errnos = [(u'ECONNREFUSED', 111),
     (u'ECONNRESET', 104),
     (u'EHOSTUNREACH', 113),
     (u'ENETUNREACH', 101),
     (u'ETIMEDOUT', 110)]
    default_gai_errnos = [(u'EAI_AGAIN', -3),
     (u'EAI_FAIL', -4),
     (u'EAI_NONAME', -2),
     (u'EAI_NODATA', -5),
     (u'WSANO_DATA', 11004)]
    denied = ResourceDenied(u'Resource %r is not available' % resource_name)
    captured_errnos = errnos
    gai_errnos = []
    if not captured_errnos:
        captured_errnos = [ getattr(errno, name, num) for name, num in default_errnos ]
        gai_errnos = [ getattr(socket, name, num) for name, num in default_gai_errnos ]

    def filter_error(err):
        n = getattr(err, u'errno', None)
        if isinstance(err, socket.timeout) or isinstance(err, socket.gaierror) and n in gai_errnos or n in captured_errnos:
            if not verbose:
                sys.stderr.write(denied.args[0] + u'\n')
            exc = denied
            exc.__cause__ = err
            raise exc
        return

    old_timeout = socket.getdefaulttimeout()
    try:
        try:
            if timeout is not None:
                socket.setdefaulttimeout(timeout)
            yield
        except IOError as err:
            while True:
                a = err.args
                if len(a) >= 1 and isinstance(a[0], IOError):
                    err = a[0]
                if len(a) >= 2 and isinstance(a[1], IOError):
                    err = a[1]
                break

            filter_error(err)
            raise

    finally:
        socket.setdefaulttimeout(old_timeout)

    return


@contextlib.contextmanager
def captured_output(stream_name):
    import io
    orig_stdout = getattr(sys, stream_name)
    setattr(sys, stream_name, io.StringIO())
    try:
        yield getattr(sys, stream_name)
    finally:
        setattr(sys, stream_name, orig_stdout)


def captured_stdout():
    return captured_output(u'stdout')


def captured_stderr():
    return captured_output(u'stderr')


def captured_stdin():
    return captured_output(u'stdin')


def gc_collect():
    gc.collect()
    if is_jython:
        time.sleep(0.1)
    gc.collect()
    gc.collect()


@contextlib.contextmanager
def disable_gc():
    have_gc = gc.isenabled()
    gc.disable()
    try:
        yield
    finally:
        if have_gc:
            gc.enable()


def python_is_optimized():
    import sysconfig
    cflags = sysconfig.get_config_var(u'PY_CFLAGS') or u''
    final_opt = u''
    for opt in cflags.split():
        if opt.startswith(u'-O'):
            final_opt = opt

    return final_opt != u'' and final_opt != u'-O0'


_header = u'nP'
_align = u'0n'
if hasattr(sys, u'gettotalrefcount'):
    _header = u'2P' + _header
    _align = u'0P'
_vheader = _header + u'n'

def calcobjsize(fmt):
    return struct.calcsize(_header + fmt + _align)


def calcvobjsize(fmt):
    return struct.calcsize(_vheader + fmt + _align)


_TPFLAGS_HAVE_GC = 16384
_TPFLAGS_HEAPTYPE = 512

def check_sizeof(test, o, size):
    result = sys.getsizeof(o)
    if type(o) == type and o.__flags__ & _TPFLAGS_HEAPTYPE or type(o) != type and type(o).__flags__ & _TPFLAGS_HAVE_GC:
        size += _testcapi.SIZEOF_PYGC_HEAD
    msg = u'wrong size for %s: got %d, expected %d' % (type(o), result, size)
    test.assertEqual(result, size, msg)


def run_with_locale(catstr, *locales):

    def decorator(func):

        def inner(*args, **kwds):
            try:
                import locale
                category = getattr(locale, catstr)
                orig_locale = locale.setlocale(category)
            except AttributeError:
                raise
            except:
                locale = orig_locale = None
            else:
                for loc in locales:
                    try:
                        locale.setlocale(category, loc)
                        break
                    except:
                        pass

            try:
                return func(*args, **kwds)
            finally:
                if locale and orig_locale:
                    locale.setlocale(category, orig_locale)

            return

        inner.__name__ = func.__name__
        inner.__doc__ = func.__doc__
        return inner

    return decorator


def run_with_tz(tz):

    def decorator(func):

        def inner(*args, **kwds):
            try:
                tzset = time.tzset
            except AttributeError:
                raise unittest.SkipTest(u'tzset required')

            if u'TZ' in os.environ:
                orig_tz = os.environ[u'TZ']
            else:
                orig_tz = None
            os.environ[u'TZ'] = tz
            tzset()
            try:
                return func(*args, **kwds)
            finally:
                if orig_tz is None:
                    del os.environ[u'TZ']
                else:
                    os.environ[u'TZ'] = orig_tz
                time.tzset()

            return

        inner.__name__ = func.__name__
        inner.__doc__ = func.__doc__
        return inner

    return decorator


_1M = 1048576
_1G = 1024 * _1M
_2G = 2 * _1G
_4G = 4 * _1G
MAX_Py_ssize_t = sys.maxsize

def set_memlimit(limit):
    global real_max_memuse
    global max_memuse
    sizes = {u'k': 1024,
     u'm': _1M,
     u'g': _1G,
     u't': 1024 * _1G}
    m = re.match(u'(\\d+(\\.\\d+)?) (K|M|G|T)b?$', limit, re.IGNORECASE | re.VERBOSE)
    if m is None:
        raise ValueError(u'Invalid memory limit %r' % (limit,))
    memlimit = int(float(m.group(1)) * sizes[m.group(3).lower()])
    real_max_memuse = memlimit
    if memlimit > MAX_Py_ssize_t:
        memlimit = MAX_Py_ssize_t
    if memlimit < _2G - 1:
        raise ValueError(u'Memory limit %r too low to be useful' % (limit,))
    max_memuse = memlimit
    return


class _MemoryWatchdog(object):

    def __init__(self):
        self.procfile = u'/proc/{pid}/statm'.format(pid=os.getpid())
        self.started = False

    def start(self):
        try:
            f = open(self.procfile, u'r')
        except OSError as e:
            warnings.warn(u'/proc not available for stats: {0}'.format(e), RuntimeWarning)
            sys.stderr.flush()
            return

        watchdog_script = findfile(u'memory_watchdog.py')
        self.mem_watchdog = subprocess.Popen([sys.executable, watchdog_script], stdin=f, stderr=subprocess.DEVNULL)
        f.close()
        self.started = True

    def stop(self):
        if self.started:
            self.mem_watchdog.terminate()
            self.mem_watchdog.wait()


def bigmemtest(size, memuse, dry_run=True):

    def decorator(f):

        def wrapper(self):
            size = wrapper.size
            memuse = wrapper.memuse
            if not real_max_memuse:
                maxsize = 5147
            else:
                maxsize = size
            if (real_max_memuse or not dry_run) and real_max_memuse < maxsize * memuse:
                raise unittest.SkipTest(u'not enough memory: %.1fG minimum needed' % (size * memuse / 1073741824))
            if real_max_memuse and verbose:
                print()
                print(u' ... expected peak memory use: {peak:.1f}G'.format(peak=size * memuse / 1073741824))
                watchdog = _MemoryWatchdog()
                watchdog.start()
            else:
                watchdog = None
            try:
                return f(self, maxsize)
            finally:
                if watchdog:
                    watchdog.stop()

            return

        wrapper.size = size
        wrapper.memuse = memuse
        return wrapper

    return decorator


def bigaddrspacetest(f):

    def wrapper(self):
        if max_memuse < MAX_Py_ssize_t:
            if MAX_Py_ssize_t >= 9223372036854775807L and max_memuse >= 2147483648L:
                raise unittest.SkipTest(u'not enough memory: try a 32-bit build instead')
            else:
                raise unittest.SkipTest(u'not enough memory: %.1fG minimum needed' % (MAX_Py_ssize_t / 1073741824))
        else:
            return f(self)

    return wrapper


class BasicTestRunner(object):

    def run(self, test):
        result = unittest.TestResult()
        test(result)
        return result


def _id(obj):
    return obj


def requires_resource(resource):
    if resource == u'gui' and not _is_gui_available():
        return unittest.skip(u"resource 'gui' is not available")
    elif is_resource_enabled(resource):
        return _id
    else:
        return unittest.skip(u'resource {0!r} is not enabled'.format(resource))


def cpython_only(test):
    return impl_detail(cpython=True)(test)


def impl_detail(msg=None, **guards):
    if check_impl_detail(**guards):
        return _id
    else:
        if msg is None:
            guardnames, default = _parse_guards(guards)
            if default:
                msg = u'implementation detail not available on {0}'
            else:
                msg = u'implementation detail specific to {0}'
            guardnames = sorted(guardnames.keys())
            msg = msg.format(u' or '.join(guardnames))
        return unittest.skip(msg)


def _parse_guards(guards):
    if not guards:
        return ({u'cpython': True}, False)
    is_true = list(guards.values())[0]
    return (guards, not is_true)


def check_impl_detail(**guards):
    guards, default = _parse_guards(guards)
    return guards.get(platform.python_implementation().lower(), default)


def no_tracing(func):
    if not hasattr(sys, u'gettrace'):
        return func
    else:

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            original_trace = sys.gettrace()
            try:
                sys.settrace(None)
                return func(*args, **kwargs)
            finally:
                sys.settrace(original_trace)

            return

        return wrapper


def refcount_test(test):
    return no_tracing(cpython_only(test))


def _filter_suite(suite, pred):
    newtests = []
    for test in suite._tests:
        if isinstance(test, unittest.TestSuite):
            _filter_suite(test, pred)
            newtests.append(test)
        if pred(test):
            newtests.append(test)

    suite._tests = newtests


def _run_suite(suite):
    if verbose:
        runner = unittest.TextTestRunner(sys.stdout, verbosity=2, failfast=failfast)
    else:
        runner = BasicTestRunner()
    result = runner.run(suite)
    if not result.wasSuccessful():
        if len(result.errors) == 1 and not result.failures:
            err = result.errors[0][1]
        elif len(result.failures) == 1 and not result.errors:
            err = result.failures[0][1]
        else:
            err = u'multiple errors occurred'
            if not verbose:
                err += u'; run in verbose mode for details'
        raise TestFailed(err)


def run_unittest(*classes):
    valid_types = (unittest.TestSuite, unittest.TestCase)
    suite = unittest.TestSuite()
    for cls in classes:
        if isinstance(cls, str):
            if cls in sys.modules:
                suite.addTest(unittest.findTestCases(sys.modules[cls]))
            else:
                raise ValueError(u'str arguments must be keys in sys.modules')
        if isinstance(cls, valid_types):
            suite.addTest(cls)
        suite.addTest(unittest.makeSuite(cls))

    def case_pred(test):
        if match_tests is None:
            return True
        else:
            for name in test.id().split(u'.'):
                if fnmatch.fnmatchcase(name, match_tests):
                    return True

            return False

    _filter_suite(suite, case_pred)
    _run_suite(suite)


def run_doctest(module, verbosity=None, optionflags=0):
    import doctest
    if verbosity is None:
        verbosity = verbose
    else:
        verbosity = None
    f, t = doctest.testmod(module, verbose=verbosity, optionflags=optionflags)
    if f:
        raise TestFailed(u'%d of %d doctests failed' % (f, t))
    if verbose:
        print(u'doctest (%s) ... %d tests with zero failures' % (module.__name__, t))
    return (f, t)


def modules_setup():
    return (sys.modules.copy(),)


def modules_cleanup(oldmodules):
    encodings = [ (k, v) for k, v in sys.modules.items() if k.startswith(u'encodings.') ]
    for i in range(len(sys.modules)):
        sys.modules.pop()

    sys.modules.update(encodings)
    sys.modules.update(oldmodules)


def threading_setup():
    if _thread:
        return (_thread._count(),)
    else:
        return (1,)


def threading_cleanup(nb_threads):
    if not _thread:
        return
    _MAX_COUNT = 10
    for count in range(_MAX_COUNT):
        n = _thread._count()
        if n == nb_threads:
            break
        time.sleep(0.1)


def reap_threads(func):
    if not _thread:
        return func

    @functools.wraps(func)
    def decorator(*args):
        key = threading_setup()
        try:
            return func(*args)
        finally:
            threading_cleanup(*key)

    return decorator


def reap_children():
    if hasattr(os, u'waitpid'):
        any_process = -1
        while True:
            try:
                pid, status = os.waitpid(any_process, os.WNOHANG)
                if pid == 0:
                    break
            except:
                break


@contextlib.contextmanager
def swap_attr(obj, attr, new_val):
    if hasattr(obj, attr):
        real_val = getattr(obj, attr)
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            setattr(obj, attr, real_val)

    else:
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            delattr(obj, attr)


@contextlib.contextmanager
def swap_item(obj, item, new_val):
    if item in obj:
        real_val = obj[item]
        obj[item] = new_val
        try:
            yield
        finally:
            obj[item] = real_val

    else:
        obj[item] = new_val
        try:
            yield
        finally:
            del obj[item]


def strip_python_stderr(stderr):
    stderr = re.sub('\\[\\d+ refs\\]\\r?\\n?', '', stderr).strip()
    return stderr


def args_from_interpreter_flags():
    return subprocess._args_from_interpreter_flags()


class TestHandler(logging.handlers.BufferingHandler):

    def __init__(self, matcher):
        logging.handlers.BufferingHandler.__init__(self, 0)
        self.matcher = matcher

    def shouldFlush(self):
        return False

    def emit(self, record):
        self.format(record)
        self.buffer.append(record.__dict__)

    def matches(self, **kwargs):
        result = False
        for d in self.buffer:
            if self.matcher.matches(d, **kwargs):
                result = True
                break

        return result


class Matcher(object):
    _partial_matches = (u'msg', u'message')

    def matches(self, d, **kwargs):
        result = True
        for k in kwargs:
            v = kwargs[k]
            dv = d.get(k)
            if not self.match_value(k, dv, v):
                result = False
                break

        return result

    def match_value(self, k, dv, v):
        if type(v) != type(dv):
            result = False
        elif type(dv) is not str or k not in self._partial_matches:
            result = v == dv
        else:
            result = dv.find(v) >= 0
        return result


_can_symlink = None

def can_symlink():
    global _can_symlink
    if _can_symlink is not None:
        return _can_symlink
    else:
        symlink_path = TESTFN + u'can_symlink'
        try:
            os.symlink(TESTFN, symlink_path)
            can = True
        except (OSError, NotImplementedError, AttributeError):
            can = False
        else:
            os.remove(symlink_path)

        _can_symlink = can
        return can


def skip_unless_symlink(test):
    ok = can_symlink()
    msg = u'Requires functional symlink implementation'
    return test if ok else unittest.skip(msg)(test)


_can_xattr = None

def can_xattr():
    global _can_xattr
    if _can_xattr is not None:
        return _can_xattr
    else:
        if not hasattr(os, u'setxattr'):
            can = False
        else:
            tmp_fp, tmp_name = tempfile.mkstemp()
            try:
                with open(TESTFN, u'wb') as fp:
                    try:
                        os.setxattr(tmp_fp, 'user.test', '')
                        os.setxattr(fp.fileno(), 'user.test', '')
                        kernel_version = platform.release()
                        m = re.match(u'2.6.(\\d{1,2})', kernel_version)
                        can = m is None or int(m.group(1)) >= 39
                    except OSError:
                        can = False

            finally:
                unlink(TESTFN)
                unlink(tmp_name)

        _can_xattr = can
        return can


def skip_unless_xattr(test):
    ok = can_xattr()
    msg = u'no non-broken extended attribute support'
    return test if ok else unittest.skip(msg)(test)


if sys.platform.startswith(u'win'):

    @contextlib.contextmanager
    def suppress_crash_popup():
        import ctypes
        k32 = ctypes.windll.kernel32
        SEM_NOGPFAULTERRORBOX = 2
        old_error_mode = k32.SetErrorMode(SEM_NOGPFAULTERRORBOX)
        k32.SetErrorMode(old_error_mode | SEM_NOGPFAULTERRORBOX)
        try:
            yield
        finally:
            k32.SetErrorMode(old_error_mode)


else:

    @contextlib.contextmanager
    def suppress_crash_popup():
        yield


def patch(test_instance, object_to_patch, attr_name, new_value):
    getattr(object_to_patch, attr_name)
    attr_is_local = False
    try:
        old_value = object_to_patch.__dict__[attr_name]
    except (AttributeError, KeyError):
        old_value = getattr(object_to_patch, attr_name, None)
    else:
        attr_is_local = True

    def cleanup():
        if attr_is_local:
            setattr(object_to_patch, attr_name, old_value)
        else:
            delattr(object_to_patch, attr_name)

    test_instance.addCleanup(cleanup)
    setattr(object_to_patch, attr_name, new_value)
    return
