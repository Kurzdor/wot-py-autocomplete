# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/utils.py
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future import utils
from future.builtins import bytes, int, str
__all__ = [u'collapse_rfc2231_value',
 u'decode_params',
 u'decode_rfc2231',
 u'encode_rfc2231',
 u'formataddr',
 u'formatdate',
 u'format_datetime',
 u'getaddresses',
 u'make_msgid',
 u'mktime_tz',
 u'parseaddr',
 u'parsedate',
 u'parsedate_tz',
 u'parsedate_to_datetime',
 u'unquote']
import os
import re
if utils.PY2:
    re.ASCII = 0
import time
import base64
import random
import socket
from future.backports import datetime
from future.backports.urllib.parse import quote as url_quote, unquote as url_unquote
import warnings
from io import StringIO
from future.backports.email._parseaddr import quote
from future.backports.email._parseaddr import AddressList as _AddressList
from future.backports.email._parseaddr import mktime_tz
from future.backports.email._parseaddr import parsedate, parsedate_tz, _parsedate_tz
from quopri import decodestring as _qdecode
from future.backports.email.encoders import _bencode, _qencode
from future.backports.email.charset import Charset
COMMASPACE = u', '
EMPTYSTRING = u''
UEMPTYSTRING = u''
CRLF = u'\r\n'
TICK = u"'"
specialsre = re.compile(u'[][\\\\()<>@,:;".]')
escapesre = re.compile(u'[\\\\"]')
_has_surrogates = re.compile(u'([^\ud800-\udbff]|\\A)[\udc00-\udfff]([^\udc00-\udfff]|\\Z)').search

def _sanitize(string):
    original_bytes = string.encode(u'ascii', u'surrogateescape')
    return original_bytes.decode(u'ascii', u'replace')


def formataddr(pair, charset=u'utf-8'):
    name, address = pair
    address.encode(u'ascii')
    if name:
        try:
            name.encode(u'ascii')
        except UnicodeEncodeError:
            if isinstance(charset, str):
                charset = Charset(charset)
            encoded_name = charset.header_encode(name)
            return u'%s <%s>' % (encoded_name, address)

        quotes = u''
        if specialsre.search(name):
            quotes = u'"'
        name = escapesre.sub(u'\\\\\\g<0>', name)
        return u'%s%s%s <%s>' % (quotes,
         name,
         quotes,
         address)
    return address


def getaddresses(fieldvalues):
    all = COMMASPACE.join(fieldvalues)
    a = _AddressList(all)
    return a.addresslist


ecre = re.compile(u'\n  =\\?                   # literal =?\n  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset\n  \\?                    # literal ?\n  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive\n  \\?                    # literal ?\n  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom\n  \\?=                   # literal ?=\n  ', re.VERBOSE | re.IGNORECASE)

def _format_timetuple_and_zone(timetuple, zone):
    return u'%s, %02d %s %04d %02d:%02d:%02d %s' % ([u'Mon',
      u'Tue',
      u'Wed',
      u'Thu',
      u'Fri',
      u'Sat',
      u'Sun'][timetuple[6]],
     timetuple[2],
     [u'Jan',
      u'Feb',
      u'Mar',
      u'Apr',
      u'May',
      u'Jun',
      u'Jul',
      u'Aug',
      u'Sep',
      u'Oct',
      u'Nov',
      u'Dec'][timetuple[1] - 1],
     timetuple[0],
     timetuple[3],
     timetuple[4],
     timetuple[5],
     zone)


def formatdate(timeval=None, localtime=False, usegmt=False):
    if timeval is None:
        timeval = time.time()
    if localtime:
        now = time.localtime(timeval)
        if time.daylight and now[-1]:
            offset = time.altzone
        else:
            offset = time.timezone
        hours, minutes = divmod(abs(offset), 3600)
        if offset > 0:
            sign = u'-'
        else:
            sign = u'+'
        zone = u'%s%02d%02d' % (sign, hours, minutes // 60)
    else:
        now = time.gmtime(timeval)
        if usegmt:
            zone = u'GMT'
        else:
            zone = u'-0000'
    return _format_timetuple_and_zone(now, zone)


def format_datetime(dt, usegmt=False):
    now = dt.timetuple()
    if usegmt:
        if dt.tzinfo is None or dt.tzinfo != datetime.timezone.utc:
            raise ValueError(u'usegmt option requires a UTC datetime')
        zone = u'GMT'
    elif dt.tzinfo is None:
        zone = u'-0000'
    else:
        zone = dt.strftime(u'%z')
    return _format_timetuple_and_zone(now, zone)


def make_msgid(idstring=None, domain=None):
    timeval = time.time()
    utcdate = time.strftime(u'%Y%m%d%H%M%S', time.gmtime(timeval))
    pid = os.getpid()
    randint = random.randrange(100000)
    if idstring is None:
        idstring = u''
    else:
        idstring = u'.' + idstring
    if domain is None:
        domain = socket.getfqdn()
    msgid = u'<%s.%s.%s%s@%s>' % (utcdate,
     pid,
     randint,
     idstring,
     domain)
    return msgid


def parsedate_to_datetime(data):
    _3to2list = list(_parsedate_tz(data))
    dtuple, tz = [_3to2list[:-1]] + _3to2list[-1:]
    return datetime.datetime(*dtuple[:6]) if tz is None else datetime.datetime(tzinfo=datetime.timezone(datetime.timedelta(seconds=tz)), *dtuple[:6])


def parseaddr(addr):
    addrs = _AddressList(addr).addresslist
    return (u'', u'') if not addrs else addrs[0]


def unquote(str):
    if len(str) > 1:
        if str.startswith(u'"') and str.endswith(u'"'):
            return str[1:-1].replace(u'\\\\', u'\\').replace(u'\\"', u'"')
        if str.startswith(u'<') and str.endswith(u'>'):
            return str[1:-1]
    return str


def decode_rfc2231(s):
    parts = s.split(TICK, 2)
    return (None, None, s) if len(parts) <= 2 else parts


def encode_rfc2231(s, charset=None, language=None):
    s = url_quote(s, safe=u'', encoding=charset or u'ascii')
    if charset is None and language is None:
        return s
    else:
        if language is None:
            language = u''
        return u"%s'%s'%s" % (charset, language, s)


rfc2231_continuation = re.compile(u'^(?P<name>\\w+)\\*((?P<num>[0-9]+)\\*?)?$', re.ASCII)

def decode_params(params):
    params = params[:]
    new_params = []
    rfc2231_params = {}
    name, value = params.pop(0)
    new_params.append((name, value))
    while params:
        name, value = params.pop(0)
        if name.endswith(u'*'):
            encoded = True
        else:
            encoded = False
        value = unquote(value)
        mo = rfc2231_continuation.match(name)
        if mo:
            name, num = mo.group(u'name', u'num')
            if num is not None:
                num = int(num)
            rfc2231_params.setdefault(name, []).append((num, value, encoded))
        new_params.append((name, u'"%s"' % quote(value)))

    if rfc2231_params:
        for name, continuations in rfc2231_params.items():
            value = []
            extended = False
            continuations.sort()
            for num, s, encoded in continuations:
                if encoded:
                    s = url_unquote(s, encoding=u'latin-1')
                    extended = True
                value.append(s)

            value = quote(EMPTYSTRING.join(value))
            if extended:
                charset, language, value = decode_rfc2231(value)
                new_params.append((name, (charset, language, u'"%s"' % value)))
            new_params.append((name, u'"%s"' % value))

    return new_params


def collapse_rfc2231_value(value, errors=u'replace', fallback_charset=u'us-ascii'):
    if not isinstance(value, tuple) or len(value) != 3:
        return unquote(value)
    charset, language, text = value
    rawbytes = bytes(text, u'raw-unicode-escape')
    try:
        return str(rawbytes, charset, errors)
    except LookupError:
        return unquote(text)


def localtime(dt=None, isdst=-1):
    if dt is None:
        return datetime.datetime.now(datetime.timezone.utc).astimezone()
    elif dt.tzinfo is not None:
        return dt.astimezone()
    else:
        tm = dt.timetuple()[:-1] + (isdst,)
        seconds = time.mktime(tm)
        localtm = time.localtime(seconds)
        try:
            delta = datetime.timedelta(seconds=localtm.tm_gmtoff)
            tz = datetime.timezone(delta, localtm.tm_zone)
        except AttributeError:
            delta = dt - datetime.datetime(*time.gmtime(seconds)[:6])
            dst = time.daylight and localtm.tm_isdst > 0
            gmtoff = -(time.altzone if dst else time.timezone)
            if delta == datetime.timedelta(seconds=gmtoff):
                tz = datetime.timezone(delta, time.tzname[dst])
            else:
                tz = datetime.timezone(delta)

        return dt.replace(tzinfo=tz)
