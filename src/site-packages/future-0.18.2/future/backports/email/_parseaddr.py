# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/_parseaddr.py
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import int
__all__ = [u'mktime_tz',
 u'parsedate',
 u'parsedate_tz',
 u'quote']
import time, calendar
SPACE = u' '
EMPTYSTRING = u''
COMMASPACE = u', '
_monthnames = [u'jan',
 u'feb',
 u'mar',
 u'apr',
 u'may',
 u'jun',
 u'jul',
 u'aug',
 u'sep',
 u'oct',
 u'nov',
 u'dec',
 u'january',
 u'february',
 u'march',
 u'april',
 u'may',
 u'june',
 u'july',
 u'august',
 u'september',
 u'october',
 u'november',
 u'december']
_daynames = [u'mon',
 u'tue',
 u'wed',
 u'thu',
 u'fri',
 u'sat',
 u'sun']
_timezones = {u'UT': 0,
 u'UTC': 0,
 u'GMT': 0,
 u'Z': 0,
 u'AST': -400,
 u'ADT': -300,
 u'EST': -500,
 u'EDT': -400,
 u'CST': -600,
 u'CDT': -500,
 u'MST': -700,
 u'MDT': -600,
 u'PST': -800,
 u'PDT': -700}

def parsedate_tz(data):
    res = _parsedate_tz(data)
    if not res:
        return
    else:
        if res[9] is None:
            res[9] = 0
        return tuple(res)


def _parsedate_tz(data):
    if not data:
        return
    else:
        data = data.split()
        if data[0].endswith(u',') or data[0].lower() in _daynames:
            del data[0]
        else:
            i = data[0].rfind(u',')
            if i >= 0:
                data[0] = data[0][i + 1:]
        if len(data) == 3:
            stuff = data[0].split(u'-')
            if len(stuff) == 3:
                data = stuff + data[1:]
        if len(data) == 4:
            s = data[3]
            i = s.find(u'+')
            if i == -1:
                i = s.find(u'-')
            if i > 0:
                data[3:] = [s[:i], s[i:]]
            else:
                data.append(u'')
        if len(data) < 5:
            return
        data = data[:5]
        dd, mm, yy, tm, tz = data
        mm = mm.lower()
        if mm not in _monthnames:
            dd, mm = mm, dd.lower()
            if mm not in _monthnames:
                return
        mm = _monthnames.index(mm) + 1
        if mm > 12:
            mm -= 12
        if dd[-1] == u',':
            dd = dd[:-1]
        i = yy.find(u':')
        if i > 0:
            yy, tm = tm, yy
        if yy[-1] == u',':
            yy = yy[:-1]
        if not yy[0].isdigit():
            yy, tz = tz, yy
        if tm[-1] == u',':
            tm = tm[:-1]
        tm = tm.split(u':')
        if len(tm) == 2:
            thh, tmm = tm
            tss = u'0'
        elif len(tm) == 3:
            thh, tmm, tss = tm
        elif len(tm) == 1 and u'.' in tm[0]:
            tm = tm[0].split(u'.')
            if len(tm) == 2:
                thh, tmm = tm
                tss = 0
            elif len(tm) == 3:
                thh, tmm, tss = tm
        else:
            return
        try:
            yy = int(yy)
            dd = int(dd)
            thh = int(thh)
            tmm = int(tmm)
            tss = int(tss)
        except ValueError:
            return

        if yy < 100:
            if yy > 68:
                yy += 1900
            else:
                yy += 2000
        tzoffset = None
        tz = tz.upper()
        if tz in _timezones:
            tzoffset = _timezones[tz]
        else:
            try:
                tzoffset = int(tz)
            except ValueError:
                pass

            if tzoffset == 0 and tz.startswith(u'-'):
                tzoffset = None
        if tzoffset:
            if tzoffset < 0:
                tzsign = -1
                tzoffset = -tzoffset
            else:
                tzsign = 1
            tzoffset = tzsign * (tzoffset // 100 * 3600 + tzoffset % 100 * 60)
        return [yy,
         mm,
         dd,
         thh,
         tmm,
         tss,
         0,
         1,
         -1,
         tzoffset]


def parsedate(data):
    t = parsedate_tz(data)
    if isinstance(t, tuple):
        return t[:9]
    else:
        return t


def mktime_tz(data):
    if data[9] is None:
        return time.mktime(data[:8] + (-1,))
    else:
        t = calendar.timegm(data)
        return t - data[9]
        return


def quote(str):
    return str.replace(u'\\', u'\\\\').replace(u'"', u'\\"')


class AddrlistClass(object):

    def __init__(self, field):
        self.specials = u'()<>@,:;."[]'
        self.pos = 0
        self.LWS = u' \t'
        self.CR = u'\r\n'
        self.FWS = self.LWS + self.CR
        self.atomends = self.specials + self.LWS + self.CR
        self.phraseends = self.atomends.replace(u'.', u'')
        self.field = field
        self.commentlist = []

    def gotonext(self):
        wslist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS + u'\n\r':
                if self.field[self.pos] not in u'\n\r':
                    wslist.append(self.field[self.pos])
                self.pos += 1
            if self.field[self.pos] == u'(':
                self.commentlist.append(self.getcomment())
            break

        return EMPTYSTRING.join(wslist)

    def getaddrlist(self):
        result = []
        while self.pos < len(self.field):
            ad = self.getaddress()
            if ad:
                result += ad
            result.append((u'', u''))

        return result

    def getaddress(self):
        self.commentlist = []
        self.gotonext()
        oldpos = self.pos
        oldcl = self.commentlist
        plist = self.getphraselist()
        self.gotonext()
        returnlist = []
        if self.pos >= len(self.field):
            if plist:
                returnlist = [(SPACE.join(self.commentlist), plist[0])]
        elif self.field[self.pos] in u'.@':
            self.pos = oldpos
            self.commentlist = oldcl
            addrspec = self.getaddrspec()
            returnlist = [(SPACE.join(self.commentlist), addrspec)]
        elif self.field[self.pos] == u':':
            returnlist = []
            fieldlen = len(self.field)
            self.pos += 1
            while self.pos < len(self.field):
                self.gotonext()
                if self.pos < fieldlen and self.field[self.pos] == u';':
                    self.pos += 1
                    break
                returnlist = returnlist + self.getaddress()

        elif self.field[self.pos] == u'<':
            routeaddr = self.getrouteaddr()
            if self.commentlist:
                returnlist = [(SPACE.join(plist) + u' (' + u' '.join(self.commentlist) + u')', routeaddr)]
            else:
                returnlist = [(SPACE.join(plist), routeaddr)]
        elif plist:
            returnlist = [(SPACE.join(self.commentlist), plist[0])]
        elif self.field[self.pos] in self.specials:
            self.pos += 1
        self.gotonext()
        if self.pos < len(self.field) and self.field[self.pos] == u',':
            self.pos += 1
        return returnlist

    def getrouteaddr(self):
        if self.field[self.pos] != u'<':
            return
        expectroute = False
        self.pos += 1
        self.gotonext()
        adlist = u''
        while self.pos < len(self.field):
            if expectroute:
                self.getdomain()
                expectroute = False
            elif self.field[self.pos] == u'>':
                self.pos += 1
                break
            elif self.field[self.pos] == u'@':
                self.pos += 1
                expectroute = True
            elif self.field[self.pos] == u':':
                self.pos += 1
            else:
                adlist = self.getaddrspec()
                self.pos += 1
                break
            self.gotonext()

        return adlist

    def getaddrspec(self):
        aslist = []
        self.gotonext()
        while self.pos < len(self.field):
            preserve_ws = True
            if self.field[self.pos] == u'.':
                if aslist and not aslist[-1].strip():
                    aslist.pop()
                aslist.append(u'.')
                self.pos += 1
                preserve_ws = False
            elif self.field[self.pos] == u'"':
                aslist.append(u'"%s"' % quote(self.getquote()))
            elif self.field[self.pos] in self.atomends:
                if aslist and not aslist[-1].strip():
                    aslist.pop()
                break
            else:
                aslist.append(self.getatom())
            ws = self.gotonext()
            if preserve_ws and ws:
                aslist.append(ws)

        if self.pos >= len(self.field) or self.field[self.pos] != u'@':
            return EMPTYSTRING.join(aslist)
        aslist.append(u'@')
        self.pos += 1
        self.gotonext()
        return EMPTYSTRING.join(aslist) + self.getdomain()

    def getdomain(self):
        sdlist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            if self.field[self.pos] == u'(':
                self.commentlist.append(self.getcomment())
            if self.field[self.pos] == u'[':
                sdlist.append(self.getdomainliteral())
            if self.field[self.pos] == u'.':
                self.pos += 1
                sdlist.append(u'.')
            if self.field[self.pos] in self.atomends:
                break
            sdlist.append(self.getatom())

        return EMPTYSTRING.join(sdlist)

    def getdelimited(self, beginchar, endchars, allowcomments=True):
        if self.field[self.pos] != beginchar:
            return u''
        slist = [u'']
        quote = False
        self.pos += 1
        while self.pos < len(self.field):
            if quote:
                slist.append(self.field[self.pos])
                quote = False
            elif self.field[self.pos] in endchars:
                self.pos += 1
                break
            elif allowcomments and self.field[self.pos] == u'(':
                slist.append(self.getcomment())
                continue
            elif self.field[self.pos] == u'\\':
                quote = True
            else:
                slist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(slist)

    def getquote(self):
        return self.getdelimited(u'"', u'"\r', False)

    def getcomment(self):
        return self.getdelimited(u'(', u')\r', True)

    def getdomainliteral(self):
        return u'[%s]' % self.getdelimited(u'[', u']\r', False)

    def getatom(self, atomends=None):
        atomlist = [u'']
        if atomends is None:
            atomends = self.atomends
        while self.pos < len(self.field):
            if self.field[self.pos] in atomends:
                break
            else:
                atomlist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(atomlist)

    def getphraselist(self):
        plist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.FWS:
                self.pos += 1
            if self.field[self.pos] == u'"':
                plist.append(self.getquote())
            if self.field[self.pos] == u'(':
                self.commentlist.append(self.getcomment())
            if self.field[self.pos] in self.phraseends:
                break
            plist.append(self.getatom(self.phraseends))

        return plist


class AddressList(AddrlistClass):

    def __init__(self, field):
        AddrlistClass.__init__(self, field)
        if field:
            self.addresslist = self.getaddrlist()
        else:
            self.addresslist = []

    def __len__(self):
        return len(self.addresslist)

    def __add__(self, other):
        newaddr = AddressList(None)
        newaddr.addresslist = self.addresslist[:]
        for x in other.addresslist:
            if x not in self.addresslist:
                newaddr.addresslist.append(x)

        return newaddr

    def __iadd__(self, other):
        for x in other.addresslist:
            if x not in self.addresslist:
                self.addresslist.append(x)

        return self

    def __sub__(self, other):
        newaddr = AddressList(None)
        for x in self.addresslist:
            if x not in other.addresslist:
                newaddr.addresslist.append(x)

        return newaddr

    def __isub__(self, other):
        for x in other.addresslist:
            if x in self.addresslist:
                self.addresslist.remove(x)

        return self

    def __getitem__(self, index):
        return self.addresslist[index]
