# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/_encoded_words.py
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import bytes
from future.builtins import chr
from future.builtins import int
from future.builtins import str
import re
import base64
import binascii
import functools
from string import ascii_letters, digits
from future.backports.email import errors
__all__ = [u'decode_q',
 u'encode_q',
 u'decode_b',
 u'encode_b',
 u'len_q',
 u'len_b',
 u'decode',
 u'encode']
_q_byte_subber = functools.partial(re.compile('=([a-fA-F0-9]{2})').sub, lambda m: bytes([int(m.group(1), 16)]))

def decode_q(encoded):
    encoded = bytes(encoded.replace('_', ' '))
    return (_q_byte_subber(encoded), [])


class _QByteMap(dict):
    safe = bytes('-!*+/' + ascii_letters.encode(u'ascii') + digits.encode(u'ascii'))

    def __missing__(self, key):
        if key in self.safe:
            self[key] = chr(key)
        else:
            self[key] = u'={:02X}'.format(key)
        return self[key]


_q_byte_map = _QByteMap()
_q_byte_map[ord(u' ')] = u'_'

def encode_q(bstring):
    return str(u''.join((_q_byte_map[x] for x in bytes(bstring))))


def len_q(bstring):
    return sum((len(_q_byte_map[x]) for x in bytes(bstring)))


def decode_b(encoded):
    defects = []
    pad_err = len(encoded) % 4
    if pad_err:
        defects.append(errors.InvalidBase64PaddingDefect())
        padded_encoded = encoded + '==='[:4 - pad_err]
    else:
        padded_encoded = encoded
    try:
        if not re.match('^[A-Za-z0-9+/]*={0,2}$', padded_encoded):
            raise binascii.Error(u'Non-base64 digit found')
        return (base64.b64decode(padded_encoded), defects)
    except binascii.Error:
        defects = [errors.InvalidBase64CharactersDefect()]
        for i in (0, 1, 2, 3):
            try:
                return (base64.b64decode(encoded + '=' * i), defects)
            except (binascii.Error, TypeError):
                if i == 0:
                    defects.append(errors.InvalidBase64PaddingDefect())

        else:
            raise AssertionError(u'unexpected binascii.Error')


def encode_b(bstring):
    return base64.b64encode(bstring).decode(u'ascii')


def len_b(bstring):
    groups_of_3, leftover = divmod(len(bstring), 3)
    return groups_of_3 * 4 + (4 if leftover else 0)


_cte_decoders = {u'q': decode_q,
 u'b': decode_b}

def decode(ew):
    _, charset, cte, cte_string, _ = str(ew).split(u'?')
    charset, _, lang = charset.partition(u'*')
    cte = cte.lower()
    bstring = cte_string.encode(u'ascii', u'surrogateescape')
    bstring, defects = _cte_decoders[cte](bstring)
    try:
        string = bstring.decode(charset)
    except UnicodeError:
        defects.append(errors.UndecodableBytesDefect(u'Encoded word contains bytes not decodable using {} charset'.format(charset)))
        string = bstring.decode(charset, u'surrogateescape')
    except LookupError:
        string = bstring.decode(u'ascii', u'surrogateescape')
        if charset.lower() != u'unknown-8bit':
            defects.append(errors.CharsetError(u'Unknown charset {} in encoded word; decoded as unknown bytes'.format(charset)))

    return (string,
     charset,
     lang,
     defects)


_cte_encoders = {u'q': encode_q,
 u'b': encode_b}
_cte_encode_length = {u'q': len_q,
 u'b': len_b}

def encode(string, charset=u'utf-8', encoding=None, lang=u''):
    string = str(string)
    if charset == u'unknown-8bit':
        bstring = string.encode(u'ascii', u'surrogateescape')
    else:
        bstring = string.encode(charset)
    if encoding is None:
        qlen = _cte_encode_length[u'q'](bstring)
        blen = _cte_encode_length[u'b'](bstring)
        encoding = u'q' if qlen - blen < 5 else u'b'
    encoded = _cte_encoders[encoding](bstring)
    if lang:
        lang = u'*' + lang
    return u'=?{0}{1}?{2}?{3}?='.format(charset, lang, encoding, encoded)
