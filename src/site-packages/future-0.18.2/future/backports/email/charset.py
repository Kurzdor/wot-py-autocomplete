# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/charset.py
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import str
from future.builtins import next
__all__ = [u'Charset',
 u'add_alias',
 u'add_charset',
 u'add_codec']
from functools import partial
from future.backports import email
from future.backports.email import errors
from future.backports.email.encoders import encode_7or8bit
QP = 1
BASE64 = 2
SHORTEST = 3
RFC2047_CHROME_LEN = 7
DEFAULT_CHARSET = u'us-ascii'
UNKNOWN8BIT = u'unknown-8bit'
EMPTYSTRING = u''
CHARSETS = {u'iso-8859-1': (QP, QP, None),
 u'iso-8859-2': (QP, QP, None),
 u'iso-8859-3': (QP, QP, None),
 u'iso-8859-4': (QP, QP, None),
 u'iso-8859-9': (QP, QP, None),
 u'iso-8859-10': (QP, QP, None),
 u'iso-8859-13': (QP, QP, None),
 u'iso-8859-14': (QP, QP, None),
 u'iso-8859-15': (QP, QP, None),
 u'iso-8859-16': (QP, QP, None),
 u'windows-1252': (QP, QP, None),
 u'viscii': (QP, QP, None),
 u'us-ascii': (None, None, None),
 u'big5': (BASE64, BASE64, None),
 u'gb2312': (BASE64, BASE64, None),
 u'euc-jp': (BASE64, None, u'iso-2022-jp'),
 u'shift_jis': (BASE64, None, u'iso-2022-jp'),
 u'iso-2022-jp': (BASE64, None, None),
 u'koi8-r': (BASE64, BASE64, None),
 u'utf-8': (SHORTEST, BASE64, u'utf-8')}
ALIASES = {u'latin_1': u'iso-8859-1',
 u'latin-1': u'iso-8859-1',
 u'latin_2': u'iso-8859-2',
 u'latin-2': u'iso-8859-2',
 u'latin_3': u'iso-8859-3',
 u'latin-3': u'iso-8859-3',
 u'latin_4': u'iso-8859-4',
 u'latin-4': u'iso-8859-4',
 u'latin_5': u'iso-8859-9',
 u'latin-5': u'iso-8859-9',
 u'latin_6': u'iso-8859-10',
 u'latin-6': u'iso-8859-10',
 u'latin_7': u'iso-8859-13',
 u'latin-7': u'iso-8859-13',
 u'latin_8': u'iso-8859-14',
 u'latin-8': u'iso-8859-14',
 u'latin_9': u'iso-8859-15',
 u'latin-9': u'iso-8859-15',
 u'latin_10': u'iso-8859-16',
 u'latin-10': u'iso-8859-16',
 u'cp949': u'ks_c_5601-1987',
 u'euc_jp': u'euc-jp',
 u'euc_kr': u'euc-kr',
 u'ascii': u'us-ascii'}
CODEC_MAP = {u'gb2312': u'eucgb2312_cn',
 u'big5': u'big5_tw',
 u'us-ascii': None}

def add_charset(charset, header_enc=None, body_enc=None, output_charset=None):
    if body_enc == SHORTEST:
        raise ValueError(u'SHORTEST not allowed for body_enc')
    CHARSETS[charset] = (header_enc, body_enc, output_charset)


def add_alias(alias, canonical):
    ALIASES[alias] = canonical


def add_codec(charset, codecname):
    CODEC_MAP[charset] = codecname


def _encode(string, codec):
    string = str(string)
    if codec == UNKNOWN8BIT:
        return string.encode(u'ascii', u'surrogateescape')
    else:
        return string.encode(codec)


class Charset(object):

    def __init__(self, input_charset=DEFAULT_CHARSET):
        try:
            if isinstance(input_charset, str):
                input_charset.encode(u'ascii')
            else:
                input_charset = str(input_charset, u'ascii')
        except UnicodeError:
            raise errors.CharsetError(input_charset)

        input_charset = input_charset.lower()
        self.input_charset = ALIASES.get(input_charset, input_charset)
        henc, benc, conv = CHARSETS.get(self.input_charset, (SHORTEST, BASE64, None))
        if not conv:
            conv = self.input_charset
        self.header_encoding = henc
        self.body_encoding = benc
        self.output_charset = ALIASES.get(conv, conv)
        self.input_codec = CODEC_MAP.get(self.input_charset, self.input_charset)
        self.output_codec = CODEC_MAP.get(self.output_charset, self.output_charset)
        return

    def __str__(self):
        return self.input_charset.lower()

    __repr__ = __str__

    def __eq__(self, other):
        return str(self) == str(other).lower()

    def __ne__(self, other):
        return not self.__eq__(other)

    def get_body_encoding(self):
        if self.body_encoding == QP:
            return u'quoted-printable'
        elif self.body_encoding == BASE64:
            return u'base64'
        else:
            return encode_7or8bit

    def get_output_charset(self):
        return self.output_charset or self.input_charset

    def header_encode(self, string):
        codec = self.output_codec or u'us-ascii'
        header_bytes = _encode(string, codec)
        encoder_module = self._get_encoder(header_bytes)
        return string if encoder_module is None else encoder_module.header_encode(header_bytes, codec)

    def header_encode_lines(self, string, maxlengths):
        codec = self.output_codec or u'us-ascii'
        header_bytes = _encode(string, codec)
        encoder_module = self._get_encoder(header_bytes)
        encoder = partial(encoder_module.header_encode, charset=codec)
        charset = self.get_output_charset()
        extra = len(charset) + RFC2047_CHROME_LEN
        lines = []
        current_line = []
        maxlen = next(maxlengths) - extra
        for character in string:
            current_line.append(character)
            this_line = EMPTYSTRING.join(current_line)
            length = encoder_module.header_length(_encode(this_line, charset))
            if length > maxlen:
                current_line.pop()
                if not lines and not current_line:
                    lines.append(None)
                else:
                    separator = u' ' if lines else u''
                    joined_line = EMPTYSTRING.join(current_line)
                    header_bytes = _encode(joined_line, codec)
                    lines.append(encoder(header_bytes))
                current_line = [character]
                maxlen = next(maxlengths) - extra

        joined_line = EMPTYSTRING.join(current_line)
        header_bytes = _encode(joined_line, codec)
        lines.append(encoder(header_bytes))
        return lines

    def _get_encoder(self, header_bytes):
        if self.header_encoding == BASE64:
            return email.base64mime
        elif self.header_encoding == QP:
            return email.quoprimime
        else:
            if self.header_encoding == SHORTEST:
                len64 = email.base64mime.header_length(header_bytes)
                lenqp = email.quoprimime.header_length(header_bytes)
                if len64 < lenqp:
                    return email.base64mime
                else:
                    return email.quoprimime
            else:
                return None
            return None

    def body_encode(self, string):
        if not string:
            return string
        elif self.body_encoding is BASE64:
            if isinstance(string, str):
                string = string.encode(self.output_charset)
            return email.base64mime.body_encode(string)
        elif self.body_encoding is QP:
            if isinstance(string, str):
                string = string.encode(self.output_charset)
            string = string.decode(u'latin1')
            return email.quoprimime.body_encode(string)
        else:
            if isinstance(string, str):
                string = string.encode(self.output_charset).decode(u'ascii')
            return string
