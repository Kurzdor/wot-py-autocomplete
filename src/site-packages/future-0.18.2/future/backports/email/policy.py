# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/policy.py
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
from future.standard_library.email._policybase import Policy, Compat32, compat32, _extend_docstrings
from future.standard_library.email.utils import _has_surrogates
from future.standard_library.email.headerregistry import HeaderRegistry
__all__ = [u'Compat32',
 u'compat32',
 u'Policy',
 u'EmailPolicy',
 u'default',
 u'strict',
 u'SMTP',
 u'HTTP']

@_extend_docstrings
class EmailPolicy(Policy):
    refold_source = u'long'
    header_factory = HeaderRegistry()

    def __init__(self, **kw):
        if u'header_factory' not in kw:
            object.__setattr__(self, u'header_factory', HeaderRegistry())
        super().__init__(**kw)

    def header_max_count(self, name):
        return self.header_factory[name].max_count

    def header_source_parse(self, sourcelines):
        name, value = sourcelines[0].split(u':', 1)
        value = value.lstrip(u' \t') + u''.join(sourcelines[1:])
        return (name, value.rstrip(u'\r\n'))

    def header_store_parse(self, name, value):
        if hasattr(value, u'name') and value.name.lower() == name.lower():
            return (name, value)
        if isinstance(value, str) and len(value.splitlines()) > 1:
            raise ValueError(u'Header values may not contain linefeed or carriage return characters')
        return (name, self.header_factory(name, value))

    def header_fetch_parse(self, name, value):
        return value if hasattr(value, u'name') else self.header_factory(name, u''.join(value.splitlines()))

    def fold(self, name, value):
        return self._fold(name, value, refold_binary=True)

    def fold_binary(self, name, value):
        folded = self._fold(name, value, refold_binary=self.cte_type == u'7bit')
        return folded.encode(u'ascii', u'surrogateescape')

    def _fold(self, name, value, refold_binary=False):
        if hasattr(value, u'name'):
            return value.fold(policy=self)
        maxlen = self.max_line_length if self.max_line_length else float(u'inf')
        lines = value.splitlines()
        refold = self.refold_source == u'all' or self.refold_source == u'long' and (lines and len(lines[0]) + len(name) + 2 > maxlen or any((len(x) > maxlen for x in lines[1:])))
        return self.header_factory(name, u''.join(lines)).fold(policy=self) if refold or refold_binary and _has_surrogates(value) else name + u': ' + self.linesep.join(lines) + self.linesep


default = EmailPolicy()
del default.header_factory
strict = default.clone(raise_on_defect=True)
SMTP = default.clone(linesep=u'\r\n')
HTTP = default.clone(linesep=u'\r\n', max_line_length=None)
