# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/email/generator.py
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
from future.builtins import str
__all__ = [u'Generator', u'DecodedGenerator', u'BytesGenerator']
import re
import sys
import time
import random
import warnings
from io import StringIO, BytesIO
from future.backports.email._policybase import compat32
from future.backports.email.header import Header
from future.backports.email.utils import _has_surrogates
import future.backports.email.charset as _charset
UNDERSCORE = u'_'
NL = u'\n'
fcre = re.compile(u'^From ', re.MULTILINE)

class Generator(object):

    def __init__(self, outfp, mangle_from_=True, maxheaderlen=None, **_3to2kwargs):
        if u'policy' in _3to2kwargs:
            policy = _3to2kwargs[u'policy']
            del _3to2kwargs[u'policy']
        else:
            policy = None
        self._fp = outfp
        self._mangle_from_ = mangle_from_
        self.maxheaderlen = maxheaderlen
        self.policy = policy
        return

    def write(self, s):
        self._fp.write(s)

    def flatten(self, msg, unixfrom=False, linesep=None):
        policy = msg.policy if self.policy is None else self.policy
        if linesep is not None:
            policy = policy.clone(linesep=linesep)
        if self.maxheaderlen is not None:
            policy = policy.clone(max_line_length=self.maxheaderlen)
        self._NL = policy.linesep
        self._encoded_NL = self._encode(self._NL)
        self._EMPTY = u''
        self._encoded_EMTPY = self._encode(u'')
        old_gen_policy = self.policy
        old_msg_policy = msg.policy
        try:
            self.policy = policy
            msg.policy = policy
            if unixfrom:
                ufrom = msg.get_unixfrom()
                if not ufrom:
                    ufrom = u'From nobody ' + time.ctime(time.time())
                self.write(ufrom + self._NL)
            self._write(msg)
        finally:
            self.policy = old_gen_policy
            msg.policy = old_msg_policy

        return

    def clone(self, fp):
        return self.__class__(fp, self._mangle_from_, None, policy=self.policy)

    _encoded_EMPTY = u''

    def _new_buffer(self):
        return StringIO()

    def _encode(self, s):
        return s

    def _write_lines(self, lines):
        if not lines:
            return
        lines = lines.splitlines(True)
        for line in lines[:-1]:
            self.write(line.rstrip(u'\r\n'))
            self.write(self._NL)

        laststripped = lines[-1].rstrip(u'\r\n')
        self.write(laststripped)
        if len(lines[-1]) != len(laststripped):
            self.write(self._NL)

    def _write(self, msg):
        oldfp = self._fp
        try:
            self._fp = sfp = self._new_buffer()
            self._dispatch(msg)
        finally:
            self._fp = oldfp

        meth = getattr(msg, u'_write_headers', None)
        if meth is None:
            self._write_headers(msg)
        else:
            meth(self)
        self._fp.write(sfp.getvalue())
        return

    def _dispatch(self, msg):
        main = msg.get_content_maintype()
        sub = msg.get_content_subtype()
        specific = UNDERSCORE.join((main, sub)).replace(u'-', u'_')
        meth = getattr(self, u'_handle_' + specific, None)
        if meth is None:
            generic = main.replace(u'-', u'_')
            meth = getattr(self, u'_handle_' + generic, None)
            if meth is None:
                meth = self._writeBody
        meth(msg)
        return

    def _write_headers(self, msg):
        for h, v in msg.raw_items():
            self.write(self.policy.fold(h, v))

        self.write(self._NL)

    def _handle_text(self, msg):
        payload = msg.get_payload()
        if payload is None:
            return
        else:
            if not isinstance(payload, str):
                raise TypeError(u'string payload expected: %s' % type(payload))
            if _has_surrogates(msg._payload):
                charset = msg.get_param(u'charset')
                if charset is not None:
                    del msg[u'content-transfer-encoding']
                    msg.set_payload(payload, charset)
                    payload = msg.get_payload()
            if self._mangle_from_:
                payload = fcre.sub(u'>From ', payload)
            self._write_lines(payload)
            return

    _writeBody = _handle_text

    def _handle_multipart(self, msg):
        msgtexts = []
        subparts = msg.get_payload()
        if subparts is None:
            subparts = []
        else:
            if isinstance(subparts, str):
                self.write(subparts)
                return
            if not isinstance(subparts, list):
                subparts = [subparts]
        for part in subparts:
            s = self._new_buffer()
            g = self.clone(s)
            g.flatten(part, unixfrom=False, linesep=self._NL)
            msgtexts.append(s.getvalue())

        boundary = msg.get_boundary()
        if not boundary:
            alltext = self._encoded_NL.join(msgtexts)
            boundary = self._make_boundary(alltext)
            msg.set_boundary(boundary)
        if msg.preamble is not None:
            if self._mangle_from_:
                preamble = fcre.sub(u'>From ', msg.preamble)
            else:
                preamble = msg.preamble
            self._write_lines(preamble)
            self.write(self._NL)
        self.write(u'--' + boundary + self._NL)
        if msgtexts:
            self._fp.write(msgtexts.pop(0))
        for body_part in msgtexts:
            self.write(self._NL + u'--' + boundary + self._NL)
            self._fp.write(body_part)

        self.write(self._NL + u'--' + boundary + u'--')
        if msg.epilogue is not None:
            self.write(self._NL)
            if self._mangle_from_:
                epilogue = fcre.sub(u'>From ', msg.epilogue)
            else:
                epilogue = msg.epilogue
            self._write_lines(epilogue)
        return

    def _handle_multipart_signed(self, msg):
        p = self.policy
        self.policy = p.clone(max_line_length=0)
        try:
            self._handle_multipart(msg)
        finally:
            self.policy = p

    def _handle_message_delivery_status(self, msg):
        blocks = []
        for part in msg.get_payload():
            s = self._new_buffer()
            g = self.clone(s)
            g.flatten(part, unixfrom=False, linesep=self._NL)
            text = s.getvalue()
            lines = text.split(self._encoded_NL)
            if lines and lines[-1] == self._encoded_EMPTY:
                blocks.append(self._encoded_NL.join(lines[:-1]))
            blocks.append(text)

        self._fp.write(self._encoded_NL.join(blocks))

    def _handle_message(self, msg):
        s = self._new_buffer()
        g = self.clone(s)
        payload = msg._payload
        if isinstance(payload, list):
            g.flatten(msg.get_payload(0), unixfrom=False, linesep=self._NL)
            payload = s.getvalue()
        else:
            payload = self._encode(payload)
        self._fp.write(payload)

    @classmethod
    def _make_boundary(cls, text=None):
        token = random.randrange(sys.maxsize)
        boundary = u'===============' + _fmt % token + u'=='
        if text is None:
            return boundary
        else:
            b = boundary
            counter = 0
            while True:
                cre = cls._compile_re(u'^--' + re.escape(b) + u'(--)?$', re.MULTILINE)
                if not cre.search(text):
                    break
                b = boundary + u'.' + str(counter)
                counter += 1

            return b

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s, flags)


class BytesGenerator(Generator):
    _encoded_EMPTY = ''

    def write(self, s):
        self._fp.write(str(s).encode(u'ascii', u'surrogateescape'))

    def _new_buffer(self):
        return BytesIO()

    def _encode(self, s):
        return s.encode(u'ascii')

    def _write_headers(self, msg):
        for h, v in msg.raw_items():
            self._fp.write(self.policy.fold_binary(h, v))

        self.write(self._NL)

    def _handle_text(self, msg):
        if msg._payload is None:
            return
        else:
            if _has_surrogates(msg._payload) and not self.policy.cte_type == u'7bit':
                if self._mangle_from_:
                    msg._payload = fcre.sub(u'>From ', msg._payload)
                self._write_lines(msg._payload)
            else:
                super(BytesGenerator, self)._handle_text(msg)
            return

    _writeBody = _handle_text

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s.encode(u'ascii'), flags)


_FMT = u'[Non-text (%(type)s) part of message omitted, filename %(filename)s]'

class DecodedGenerator(Generator):

    def __init__(self, outfp, mangle_from_=True, maxheaderlen=78, fmt=None):
        Generator.__init__(self, outfp, mangle_from_, maxheaderlen)
        if fmt is None:
            self._fmt = _FMT
        else:
            self._fmt = fmt
        return

    def _dispatch(self, msg):
        for part in msg.walk():
            maintype = part.get_content_maintype()
            if maintype == u'text':
                print(part.get_payload(decode=False), file=self)
            if maintype == u'multipart':
                pass
            print(self._fmt % {u'type': part.get_content_type(),
             u'maintype': part.get_content_maintype(),
             u'subtype': part.get_content_subtype(),
             u'filename': part.get_filename(u'[no filename]'),
             u'description': part.get(u'Content-Description', u'[no description]'),
             u'encoding': part.get(u'Content-Transfer-Encoding', u'[no encoding]')}, file=self)


_width = len(repr(sys.maxsize - 1))
_fmt = u'%%0%dd' % _width
_make_boundary = Generator._make_boundary
