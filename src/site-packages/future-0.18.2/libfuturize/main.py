# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/libfuturize/main.py
from __future__ import absolute_import, print_function, unicode_literals
import future.utils
from future import __version__
import sys
import logging
import optparse
import os
from lib2to3.main import warn, StdoutRefactoringTool
from lib2to3 import refactor
from libfuturize.fixes import lib2to3_fix_names_stage1, lib2to3_fix_names_stage2, libfuturize_fix_names_stage1, libfuturize_fix_names_stage2
fixer_pkg = u'libfuturize.fixes'

def main(args=None):
    parser = optparse.OptionParser(usage=u'futurize [options] file|dir ...')
    parser.add_option(u'-V', u'--version', action=u'store_true', help=u'Report the version number of futurize')
    parser.add_option(u'-a', u'--all-imports', action=u'store_true', help=u'Add all __future__ and future imports to each module')
    parser.add_option(u'-1', u'--stage1', action=u'store_true', help=u'Modernize Python 2 code only; no compatibility with Python 3 (or dependency on ``future``)')
    parser.add_option(u'-2', u'--stage2', action=u'store_true', help=u'Take modernized (stage1) code and add a dependency on ``future`` to provide Py3 compatibility.')
    parser.add_option(u'-0', u'--both-stages', action=u'store_true', help=u'Apply both stages 1 and 2')
    parser.add_option(u'-u', u'--unicode-literals', action=u'store_true', help=u"Add ``from __future__ import unicode_literals`` to implicitly convert all unadorned string literals '' into unicode strings")
    parser.add_option(u'-f', u'--fix', action=u'append', default=[], help=u"Each FIX specifies a transformation; default: all.\nEither use '-f division -f metaclass' etc. or use the fully-qualified module name: '-f lib2to3.fixes.fix_types -f libfuturize.fixes.fix_unicode_keep_u'")
    parser.add_option(u'-j', u'--processes', action=u'store', default=1, type=u'int', help=u'Run 2to3 concurrently')
    parser.add_option(u'-x', u'--nofix', action=u'append', default=[], help=u'Prevent a fixer from being run.')
    parser.add_option(u'-l', u'--list-fixes', action=u'store_true', help=u'List available transformations')
    parser.add_option(u'-p', u'--print-function', action=u'store_true', help=u'Modify the grammar so that print() is a function')
    parser.add_option(u'-v', u'--verbose', action=u'store_true', help=u'More verbose logging')
    parser.add_option(u'--no-diffs', action=u'store_true', help=u"Don't show diffs of the refactoring")
    parser.add_option(u'-w', u'--write', action=u'store_true', help=u'Write back modified files')
    parser.add_option(u'-n', u'--nobackups', action=u'store_true', default=False, help=u"Don't write backups for modified files.")
    parser.add_option(u'-o', u'--output-dir', action=u'store', type=u'str', default=u'', help=u'Put output files in this directory instead of overwriting the input files.  Requires -n. For Python >= 2.7 only.')
    parser.add_option(u'-W', u'--write-unchanged-files', action=u'store_true', help=u'Also write files even if no changes were required (useful with --output-dir); implies -w.')
    parser.add_option(u'--add-suffix', action=u'store', type=u'str', default=u'', help=u"Append this string to all output filenames. Requires -n if non-empty. For Python >= 2.7 only.ex: --add-suffix='3' will generate .py3 files.")
    flags = {}
    refactor_stdin = False
    options, args = parser.parse_args(args)
    if options.write_unchanged_files:
        flags[u'write_unchanged_files'] = True
        if not options.write:
            warn(u'--write-unchanged-files/-W implies -w.')
        options.write = True
    if options.output_dir and not options.nobackups:
        parser.error(u"Can't use --output-dir/-o without -n.")
    if options.add_suffix and not options.nobackups:
        parser.error(u"Can't use --add-suffix without -n.")
    if not options.write and options.no_diffs:
        warn(u"not writing files and not printing diffs; that's not very useful")
    if not options.write and options.nobackups:
        parser.error(u"Can't use -n without -w")
    if u'-' in args:
        refactor_stdin = True
        if options.write:
            print(u"Can't write to stdin.", file=sys.stderr)
            return 2
    if options.print_function:
        flags[u'print_function'] = True
    level = logging.DEBUG if options.verbose else logging.INFO
    logging.basicConfig(format=u'%(name)s: %(message)s', level=level)
    logger = logging.getLogger(u'libfuturize.main')
    if options.stage1 or options.stage2:
        options.both_stages = False
    else:
        options.both_stages = True
    avail_fixes = set()
    if options.stage1 or options.both_stages:
        avail_fixes.update(lib2to3_fix_names_stage1)
        avail_fixes.update(libfuturize_fix_names_stage1)
    if options.stage2 or options.both_stages:
        avail_fixes.update(lib2to3_fix_names_stage2)
        avail_fixes.update(libfuturize_fix_names_stage2)
    if options.unicode_literals:
        avail_fixes.add(u'libfuturize.fixes.fix_unicode_literals_import')
    if options.version:
        print(__version__)
        return 0
    else:
        if options.list_fixes:
            print(u'Available transformations for the -f/--fix option:')
            for fixname in sorted(avail_fixes):
                print(fixname)

            if not args:
                return 0
        if not args:
            print(u'At least one file or directory argument required.', file=sys.stderr)
            print(u'Use --help to show usage.', file=sys.stderr)
            return 2
        unwanted_fixes = set()
        for fix in options.nofix:
            if u'.fix_' in fix:
                unwanted_fixes.add(fix)
            found = [ f for f in avail_fixes if f.endswith(u'fix_{0}'.format(fix)) ]
            if len(found) > 1:
                print(u'Ambiguous fixer name. Choose a fully qualified module name instead from these:\n' + u'\n'.join((u'  ' + myf for myf in found)), file=sys.stderr)
                return 2
            if len(found) == 0:
                print(u'Unknown fixer. Use --list-fixes or -l for a list.', file=sys.stderr)
                return 2
            unwanted_fixes.add(found[0])

        extra_fixes = set()
        if options.all_imports:
            if options.stage1:
                prefix = u'libfuturize.fixes.'
                extra_fixes.add(prefix + u'fix_add__future__imports_except_unicode_literals')
            else:
                prefix = u'libpasteurize.fixes.'
                extra_fixes.add(prefix + u'fix_add_all__future__imports')
                extra_fixes.add(prefix + u'fix_add_future_standard_library_import')
                extra_fixes.add(prefix + u'fix_add_all_future_builtins')
        explicit = set()
        if options.fix:
            all_present = False
            for fix in options.fix:
                if fix == u'all':
                    all_present = True
                if u'.fix_' in fix:
                    explicit.add(fix)
                found = [ f for f in avail_fixes if f.endswith(u'fix_{0}'.format(fix)) ]
                if len(found) > 1:
                    print(u'Ambiguous fixer name. Choose a fully qualified module name instead from these:\n' + u'\n'.join((u'  ' + myf for myf in found)), file=sys.stderr)
                    return 2
                if len(found) == 0:
                    print(u'Unknown fixer. Use --list-fixes or -l for a list.', file=sys.stderr)
                    return 2
                explicit.add(found[0])

            if len(explicit & unwanted_fixes) > 0:
                print(u'Conflicting usage: the following fixers have been simultaneously requested and disallowed:\n' + u'\n'.join((u'  ' + myf for myf in explicit & unwanted_fixes)), file=sys.stderr)
                return 2
            requested = avail_fixes.union(explicit) if all_present else explicit
        else:
            requested = avail_fixes.union(explicit)
        fixer_names = (requested | extra_fixes) - unwanted_fixes
        input_base_dir = os.path.commonprefix(args)
        if input_base_dir and not input_base_dir.endswith(os.sep) and not os.path.isdir(input_base_dir):
            input_base_dir = os.path.dirname(input_base_dir)
        if options.output_dir:
            input_base_dir = input_base_dir.rstrip(os.sep)
            logger.info(u'Output in %r will mirror the input directory %r layout.', options.output_dir, input_base_dir)
        if future.utils.PY26:
            extra_kwargs = {}
        else:
            extra_kwargs = {u'append_suffix': options.add_suffix,
             u'output_dir': options.output_dir,
             u'input_base_dir': input_base_dir}
        rt = StdoutRefactoringTool(sorted(fixer_names), flags, sorted(explicit), options.nobackups, (not options.no_diffs), **extra_kwargs)
        if not rt.errors:
            if refactor_stdin:
                rt.refactor_stdin()
            else:
                try:
                    rt.refactor(args, options.write, None, options.processes)
                except refactor.MultiprocessingUnsupported:
                    print(u"Sorry, -j isn't supported on this platform.", file=sys.stderr)
                    return 1

            rt.summarize()
        return int(bool(rt.errors))
